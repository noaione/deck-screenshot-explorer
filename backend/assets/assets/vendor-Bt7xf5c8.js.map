{"version":3,"file":"vendor-Bt7xf5c8.js","sources":["../../node_modules/pinia/node_modules/vue-demi/lib/index.mjs","../../node_modules/pinia/dist/pinia.mjs","../../node_modules/hookable/dist/index.mjs","../../node_modules/@unhead/shared/dist/index.mjs","../../node_modules/@unhead/dom/dist/index.mjs","../../node_modules/unhead/dist/index.mjs","../../node_modules/@unhead/vue/dist/shared/vue.cf295fb1.mjs","../../node_modules/pinia-plugin-persistedstate/dist/index.mjs"],"sourcesContent":["import * as Vue from 'vue'\n\nvar isVue2 = false\nvar isVue3 = true\nvar Vue2 = undefined\n\nfunction install() {}\n\nexport function set(target, key, val) {\n  if (Array.isArray(target)) {\n    target.length = Math.max(target.length, key)\n    target.splice(key, 1, val)\n    return val\n  }\n  target[key] = val\n  return val\n}\n\nexport function del(target, key) {\n  if (Array.isArray(target)) {\n    target.splice(key, 1)\n    return\n  }\n  delete target[key]\n}\n\nexport * from 'vue'\nexport {\n  Vue,\n  Vue2,\n  isVue2,\n  isVue3,\n  install,\n}\n","/*!\n * pinia v2.1.7\n * (c) 2023 Eduardo San Martin Morote\n * @license MIT\n */\nimport { hasInjectionContext, inject, toRaw, watch, unref, markRaw, effectScope, ref, isVue2, isRef, isReactive, set, getCurrentScope, onScopeDispose, getCurrentInstance, reactive, toRef, del, nextTick, computed, toRefs } from 'vue-demi';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\n\n/**\n * setActivePinia must be called to handle SSR at the top of functions like\n * `fetch`, `setup`, `serverPrefetch` and others\n */\nlet activePinia;\n/**\n * Sets or unsets the active pinia. Used in SSR and internally when calling\n * actions and getters\n *\n * @param pinia - Pinia instance\n */\n// @ts-expect-error: cannot constrain the type of the return\nconst setActivePinia = (pinia) => (activePinia = pinia);\n/**\n * Get the currently active pinia if there is any.\n */\nconst getActivePinia = () => (hasInjectionContext() && inject(piniaSymbol)) || activePinia;\nconst piniaSymbol = ((process.env.NODE_ENV !== 'production') ? Symbol('pinia') : /* istanbul ignore next */ Symbol());\n\nfunction isPlainObject(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\no) {\n    return (o &&\n        typeof o === 'object' &&\n        Object.prototype.toString.call(o) === '[object Object]' &&\n        typeof o.toJSON !== 'function');\n}\n// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }\n// TODO: can we change these to numbers?\n/**\n * Possible types for SubscriptionCallback\n */\nvar MutationType;\n(function (MutationType) {\n    /**\n     * Direct mutation of the state:\n     *\n     * - `store.name = 'new name'`\n     * - `store.$state.name = 'new name'`\n     * - `store.list.push('new item')`\n     */\n    MutationType[\"direct\"] = \"direct\";\n    /**\n     * Mutated the state with `$patch` and an object\n     *\n     * - `store.$patch({ name: 'newName' })`\n     */\n    MutationType[\"patchObject\"] = \"patch object\";\n    /**\n     * Mutated the state with `$patch` and a function\n     *\n     * - `store.$patch(state => state.name = 'newName')`\n     */\n    MutationType[\"patchFunction\"] = \"patch function\";\n    // maybe reset? for $state = {} and $reset\n})(MutationType || (MutationType = {}));\n\nconst IS_CLIENT = typeof window !== 'undefined';\n/**\n * Should we add the devtools plugins.\n * - only if dev mode or forced through the prod devtools flag\n * - not in test\n * - only if window exists (could change in the future)\n */\nconst USE_DEVTOOLS = ((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test') && IS_CLIENT;\n\n/*\n * FileSaver.js A saveAs() FileSaver implementation.\n *\n * Originally by Eli Grey, adapted as an ESM module by Eduardo San Martin\n * Morote.\n *\n * License : MIT\n */\n// The one and only way of getting global scope in all environments\n// https://stackoverflow.com/q/3277182/1008999\nconst _global = /*#__PURE__*/ (() => typeof window === 'object' && window.window === window\n    ? window\n    : typeof self === 'object' && self.self === self\n        ? self\n        : typeof global === 'object' && global.global === global\n            ? global\n            : typeof globalThis === 'object'\n                ? globalThis\n                : { HTMLElement: null })();\nfunction bom(blob, { autoBom = false } = {}) {\n    // prepend BOM for UTF-8 XML and text/* types (including HTML)\n    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n    if (autoBom &&\n        /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n        return new Blob([String.fromCharCode(0xfeff), blob], { type: blob.type });\n    }\n    return blob;\n}\nfunction download(url, name, opts) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    xhr.responseType = 'blob';\n    xhr.onload = function () {\n        saveAs(xhr.response, name, opts);\n    };\n    xhr.onerror = function () {\n        console.error('could not download file');\n    };\n    xhr.send();\n}\nfunction corsEnabled(url) {\n    const xhr = new XMLHttpRequest();\n    // use sync to avoid popup blocker\n    xhr.open('HEAD', url, false);\n    try {\n        xhr.send();\n    }\n    catch (e) { }\n    return xhr.status >= 200 && xhr.status <= 299;\n}\n// `a.click()` doesn't work for all browsers (#465)\nfunction click(node) {\n    try {\n        node.dispatchEvent(new MouseEvent('click'));\n    }\n    catch (e) {\n        const evt = document.createEvent('MouseEvents');\n        evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);\n        node.dispatchEvent(evt);\n    }\n}\nconst _navigator = \n typeof navigator === 'object' ? navigator : { userAgent: '' };\n// Detect WebView inside a native macOS app by ruling out all browsers\n// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too\n// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos\nconst isMacOSWebView = /*#__PURE__*/ (() => /Macintosh/.test(_navigator.userAgent) &&\n    /AppleWebKit/.test(_navigator.userAgent) &&\n    !/Safari/.test(_navigator.userAgent))();\nconst saveAs = !IS_CLIENT\n    ? () => { } // noop\n    : // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program\n        typeof HTMLAnchorElement !== 'undefined' &&\n            'download' in HTMLAnchorElement.prototype &&\n            !isMacOSWebView\n            ? downloadSaveAs\n            : // Use msSaveOrOpenBlob as a second approach\n                'msSaveOrOpenBlob' in _navigator\n                    ? msSaveAs\n                    : // Fallback to using FileReader and a popup\n                        fileSaverSaveAs;\nfunction downloadSaveAs(blob, name = 'download', opts) {\n    const a = document.createElement('a');\n    a.download = name;\n    a.rel = 'noopener'; // tabnabbing\n    // TODO: detect chrome extensions & packaged apps\n    // a.target = '_blank'\n    if (typeof blob === 'string') {\n        // Support regular links\n        a.href = blob;\n        if (a.origin !== location.origin) {\n            if (corsEnabled(a.href)) {\n                download(blob, name, opts);\n            }\n            else {\n                a.target = '_blank';\n                click(a);\n            }\n        }\n        else {\n            click(a);\n        }\n    }\n    else {\n        // Support blobs\n        a.href = URL.createObjectURL(blob);\n        setTimeout(function () {\n            URL.revokeObjectURL(a.href);\n        }, 4e4); // 40s\n        setTimeout(function () {\n            click(a);\n        }, 0);\n    }\n}\nfunction msSaveAs(blob, name = 'download', opts) {\n    if (typeof blob === 'string') {\n        if (corsEnabled(blob)) {\n            download(blob, name, opts);\n        }\n        else {\n            const a = document.createElement('a');\n            a.href = blob;\n            a.target = '_blank';\n            setTimeout(function () {\n                click(a);\n            });\n        }\n    }\n    else {\n        // @ts-ignore: works on windows\n        navigator.msSaveOrOpenBlob(bom(blob, opts), name);\n    }\n}\nfunction fileSaverSaveAs(blob, name, opts, popup) {\n    // Open a popup immediately do go around popup blocker\n    // Mostly only available on user interaction and the fileReader is async so...\n    popup = popup || open('', '_blank');\n    if (popup) {\n        popup.document.title = popup.document.body.innerText = 'downloading...';\n    }\n    if (typeof blob === 'string')\n        return download(blob, name, opts);\n    const force = blob.type === 'application/octet-stream';\n    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || 'safari' in _global;\n    const isChromeIOS = /CriOS\\/[\\d]+/.test(navigator.userAgent);\n    if ((isChromeIOS || (force && isSafari) || isMacOSWebView) &&\n        typeof FileReader !== 'undefined') {\n        // Safari doesn't allow downloading of blob URLs\n        const reader = new FileReader();\n        reader.onloadend = function () {\n            let url = reader.result;\n            if (typeof url !== 'string') {\n                popup = null;\n                throw new Error('Wrong reader.result type');\n            }\n            url = isChromeIOS\n                ? url\n                : url.replace(/^data:[^;]*;/, 'data:attachment/file;');\n            if (popup) {\n                popup.location.href = url;\n            }\n            else {\n                location.assign(url);\n            }\n            popup = null; // reverse-tabnabbing #460\n        };\n        reader.readAsDataURL(blob);\n    }\n    else {\n        const url = URL.createObjectURL(blob);\n        if (popup)\n            popup.location.assign(url);\n        else\n            location.href = url;\n        popup = null; // reverse-tabnabbing #460\n        setTimeout(function () {\n            URL.revokeObjectURL(url);\n        }, 4e4); // 40s\n    }\n}\n\n/**\n * Shows a toast or console.log\n *\n * @param message - message to log\n * @param type - different color of the tooltip\n */\nfunction toastMessage(message, type) {\n    const piniaMessage = '🍍 ' + message;\n    if (typeof __VUE_DEVTOOLS_TOAST__ === 'function') {\n        // No longer available :(\n        __VUE_DEVTOOLS_TOAST__(piniaMessage, type);\n    }\n    else if (type === 'error') {\n        console.error(piniaMessage);\n    }\n    else if (type === 'warn') {\n        console.warn(piniaMessage);\n    }\n    else {\n        console.log(piniaMessage);\n    }\n}\nfunction isPinia(o) {\n    return '_a' in o && 'install' in o;\n}\n\n/**\n * This file contain devtools actions, they are not Pinia actions.\n */\n// ---\nfunction checkClipboardAccess() {\n    if (!('clipboard' in navigator)) {\n        toastMessage(`Your browser doesn't support the Clipboard API`, 'error');\n        return true;\n    }\n}\nfunction checkNotFocusedError(error) {\n    if (error instanceof Error &&\n        error.message.toLowerCase().includes('document is not focused')) {\n        toastMessage('You need to activate the \"Emulate a focused page\" setting in the \"Rendering\" panel of devtools.', 'warn');\n        return true;\n    }\n    return false;\n}\nasync function actionGlobalCopyState(pinia) {\n    if (checkClipboardAccess())\n        return;\n    try {\n        await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));\n        toastMessage('Global state copied to clipboard.');\n    }\n    catch (error) {\n        if (checkNotFocusedError(error))\n            return;\n        toastMessage(`Failed to serialize the state. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nasync function actionGlobalPasteState(pinia) {\n    if (checkClipboardAccess())\n        return;\n    try {\n        loadStoresState(pinia, JSON.parse(await navigator.clipboard.readText()));\n        toastMessage('Global state pasted from clipboard.');\n    }\n    catch (error) {\n        if (checkNotFocusedError(error))\n            return;\n        toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nasync function actionGlobalSaveState(pinia) {\n    try {\n        saveAs(new Blob([JSON.stringify(pinia.state.value)], {\n            type: 'text/plain;charset=utf-8',\n        }), 'pinia-state.json');\n    }\n    catch (error) {\n        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nlet fileInput;\nfunction getFileOpener() {\n    if (!fileInput) {\n        fileInput = document.createElement('input');\n        fileInput.type = 'file';\n        fileInput.accept = '.json';\n    }\n    function openFile() {\n        return new Promise((resolve, reject) => {\n            fileInput.onchange = async () => {\n                const files = fileInput.files;\n                if (!files)\n                    return resolve(null);\n                const file = files.item(0);\n                if (!file)\n                    return resolve(null);\n                return resolve({ text: await file.text(), file });\n            };\n            // @ts-ignore: TODO: changed from 4.3 to 4.4\n            fileInput.oncancel = () => resolve(null);\n            fileInput.onerror = reject;\n            fileInput.click();\n        });\n    }\n    return openFile;\n}\nasync function actionGlobalOpenStateFile(pinia) {\n    try {\n        const open = getFileOpener();\n        const result = await open();\n        if (!result)\n            return;\n        const { text, file } = result;\n        loadStoresState(pinia, JSON.parse(text));\n        toastMessage(`Global state imported from \"${file.name}\".`);\n    }\n    catch (error) {\n        toastMessage(`Failed to import the state from JSON. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nfunction loadStoresState(pinia, state) {\n    for (const key in state) {\n        const storeState = pinia.state.value[key];\n        // store is already instantiated, patch it\n        if (storeState) {\n            Object.assign(storeState, state[key]);\n        }\n        else {\n            // store is not instantiated, set the initial state\n            pinia.state.value[key] = state[key];\n        }\n    }\n}\n\nfunction formatDisplay(display) {\n    return {\n        _custom: {\n            display,\n        },\n    };\n}\nconst PINIA_ROOT_LABEL = '🍍 Pinia (root)';\nconst PINIA_ROOT_ID = '_root';\nfunction formatStoreForInspectorTree(store) {\n    return isPinia(store)\n        ? {\n            id: PINIA_ROOT_ID,\n            label: PINIA_ROOT_LABEL,\n        }\n        : {\n            id: store.$id,\n            label: store.$id,\n        };\n}\nfunction formatStoreForInspectorState(store) {\n    if (isPinia(store)) {\n        const storeNames = Array.from(store._s.keys());\n        const storeMap = store._s;\n        const state = {\n            state: storeNames.map((storeId) => ({\n                editable: true,\n                key: storeId,\n                value: store.state.value[storeId],\n            })),\n            getters: storeNames\n                .filter((id) => storeMap.get(id)._getters)\n                .map((id) => {\n                const store = storeMap.get(id);\n                return {\n                    editable: false,\n                    key: id,\n                    value: store._getters.reduce((getters, key) => {\n                        getters[key] = store[key];\n                        return getters;\n                    }, {}),\n                };\n            }),\n        };\n        return state;\n    }\n    const state = {\n        state: Object.keys(store.$state).map((key) => ({\n            editable: true,\n            key,\n            value: store.$state[key],\n        })),\n    };\n    // avoid adding empty getters\n    if (store._getters && store._getters.length) {\n        state.getters = store._getters.map((getterName) => ({\n            editable: false,\n            key: getterName,\n            value: store[getterName],\n        }));\n    }\n    if (store._customProperties.size) {\n        state.customProperties = Array.from(store._customProperties).map((key) => ({\n            editable: true,\n            key,\n            value: store[key],\n        }));\n    }\n    return state;\n}\nfunction formatEventData(events) {\n    if (!events)\n        return {};\n    if (Array.isArray(events)) {\n        // TODO: handle add and delete for arrays and objects\n        return events.reduce((data, event) => {\n            data.keys.push(event.key);\n            data.operations.push(event.type);\n            data.oldValue[event.key] = event.oldValue;\n            data.newValue[event.key] = event.newValue;\n            return data;\n        }, {\n            oldValue: {},\n            keys: [],\n            operations: [],\n            newValue: {},\n        });\n    }\n    else {\n        return {\n            operation: formatDisplay(events.type),\n            key: formatDisplay(events.key),\n            oldValue: events.oldValue,\n            newValue: events.newValue,\n        };\n    }\n}\nfunction formatMutationType(type) {\n    switch (type) {\n        case MutationType.direct:\n            return 'mutation';\n        case MutationType.patchFunction:\n            return '$patch';\n        case MutationType.patchObject:\n            return '$patch';\n        default:\n            return 'unknown';\n    }\n}\n\n// timeline can be paused when directly changing the state\nlet isTimelineActive = true;\nconst componentStateTypes = [];\nconst MUTATIONS_LAYER_ID = 'pinia:mutations';\nconst INSPECTOR_ID = 'pinia';\nconst { assign: assign$1 } = Object;\n/**\n * Gets the displayed name of a store in devtools\n *\n * @param id - id of the store\n * @returns a formatted string\n */\nconst getStoreType = (id) => '🍍 ' + id;\n/**\n * Add the pinia plugin without any store. Allows displaying a Pinia plugin tab\n * as soon as it is added to the application.\n *\n * @param app - Vue application\n * @param pinia - pinia instance\n */\nfunction registerPiniaDevtools(app, pinia) {\n    setupDevtoolsPlugin({\n        id: 'dev.esm.pinia',\n        label: 'Pinia 🍍',\n        logo: 'https://pinia.vuejs.org/logo.svg',\n        packageName: 'pinia',\n        homepage: 'https://pinia.vuejs.org',\n        componentStateTypes,\n        app,\n    }, (api) => {\n        if (typeof api.now !== 'function') {\n            toastMessage('You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.');\n        }\n        api.addTimelineLayer({\n            id: MUTATIONS_LAYER_ID,\n            label: `Pinia 🍍`,\n            color: 0xe5df88,\n        });\n        api.addInspector({\n            id: INSPECTOR_ID,\n            label: 'Pinia 🍍',\n            icon: 'storage',\n            treeFilterPlaceholder: 'Search stores',\n            actions: [\n                {\n                    icon: 'content_copy',\n                    action: () => {\n                        actionGlobalCopyState(pinia);\n                    },\n                    tooltip: 'Serialize and copy the state',\n                },\n                {\n                    icon: 'content_paste',\n                    action: async () => {\n                        await actionGlobalPasteState(pinia);\n                        api.sendInspectorTree(INSPECTOR_ID);\n                        api.sendInspectorState(INSPECTOR_ID);\n                    },\n                    tooltip: 'Replace the state with the content of your clipboard',\n                },\n                {\n                    icon: 'save',\n                    action: () => {\n                        actionGlobalSaveState(pinia);\n                    },\n                    tooltip: 'Save the state as a JSON file',\n                },\n                {\n                    icon: 'folder_open',\n                    action: async () => {\n                        await actionGlobalOpenStateFile(pinia);\n                        api.sendInspectorTree(INSPECTOR_ID);\n                        api.sendInspectorState(INSPECTOR_ID);\n                    },\n                    tooltip: 'Import the state from a JSON file',\n                },\n            ],\n            nodeActions: [\n                {\n                    icon: 'restore',\n                    tooltip: 'Reset the state (with \"$reset\")',\n                    action: (nodeId) => {\n                        const store = pinia._s.get(nodeId);\n                        if (!store) {\n                            toastMessage(`Cannot reset \"${nodeId}\" store because it wasn't found.`, 'warn');\n                        }\n                        else if (typeof store.$reset !== 'function') {\n                            toastMessage(`Cannot reset \"${nodeId}\" store because it doesn't have a \"$reset\" method implemented.`, 'warn');\n                        }\n                        else {\n                            store.$reset();\n                            toastMessage(`Store \"${nodeId}\" reset.`);\n                        }\n                    },\n                },\n            ],\n        });\n        api.on.inspectComponent((payload, ctx) => {\n            const proxy = (payload.componentInstance &&\n                payload.componentInstance.proxy);\n            if (proxy && proxy._pStores) {\n                const piniaStores = payload.componentInstance.proxy._pStores;\n                Object.values(piniaStores).forEach((store) => {\n                    payload.instanceData.state.push({\n                        type: getStoreType(store.$id),\n                        key: 'state',\n                        editable: true,\n                        value: store._isOptionsAPI\n                            ? {\n                                _custom: {\n                                    value: toRaw(store.$state),\n                                    actions: [\n                                        {\n                                            icon: 'restore',\n                                            tooltip: 'Reset the state of this store',\n                                            action: () => store.$reset(),\n                                        },\n                                    ],\n                                },\n                            }\n                            : // NOTE: workaround to unwrap transferred refs\n                                Object.keys(store.$state).reduce((state, key) => {\n                                    state[key] = store.$state[key];\n                                    return state;\n                                }, {}),\n                    });\n                    if (store._getters && store._getters.length) {\n                        payload.instanceData.state.push({\n                            type: getStoreType(store.$id),\n                            key: 'getters',\n                            editable: false,\n                            value: store._getters.reduce((getters, key) => {\n                                try {\n                                    getters[key] = store[key];\n                                }\n                                catch (error) {\n                                    // @ts-expect-error: we just want to show it in devtools\n                                    getters[key] = error;\n                                }\n                                return getters;\n                            }, {}),\n                        });\n                    }\n                });\n            }\n        });\n        api.on.getInspectorTree((payload) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                let stores = [pinia];\n                stores = stores.concat(Array.from(pinia._s.values()));\n                payload.rootNodes = (payload.filter\n                    ? stores.filter((store) => '$id' in store\n                        ? store.$id\n                            .toLowerCase()\n                            .includes(payload.filter.toLowerCase())\n                        : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase()))\n                    : stores).map(formatStoreForInspectorTree);\n            }\n        });\n        api.on.getInspectorState((payload) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\n                    ? pinia\n                    : pinia._s.get(payload.nodeId);\n                if (!inspectedStore) {\n                    // this could be the selected store restored for a different project\n                    // so it's better not to say anything here\n                    return;\n                }\n                if (inspectedStore) {\n                    payload.state = formatStoreForInspectorState(inspectedStore);\n                }\n            }\n        });\n        api.on.editInspectorState((payload, ctx) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\n                    ? pinia\n                    : pinia._s.get(payload.nodeId);\n                if (!inspectedStore) {\n                    return toastMessage(`store \"${payload.nodeId}\" not found`, 'error');\n                }\n                const { path } = payload;\n                if (!isPinia(inspectedStore)) {\n                    // access only the state\n                    if (path.length !== 1 ||\n                        !inspectedStore._customProperties.has(path[0]) ||\n                        path[0] in inspectedStore.$state) {\n                        path.unshift('$state');\n                    }\n                }\n                else {\n                    // Root access, we can omit the `.value` because the devtools API does it for us\n                    path.unshift('state');\n                }\n                isTimelineActive = false;\n                payload.set(inspectedStore, path, payload.state.value);\n                isTimelineActive = true;\n            }\n        });\n        api.on.editComponentState((payload) => {\n            if (payload.type.startsWith('🍍')) {\n                const storeId = payload.type.replace(/^🍍\\s*/, '');\n                const store = pinia._s.get(storeId);\n                if (!store) {\n                    return toastMessage(`store \"${storeId}\" not found`, 'error');\n                }\n                const { path } = payload;\n                if (path[0] !== 'state') {\n                    return toastMessage(`Invalid path for store \"${storeId}\":\\n${path}\\nOnly state can be modified.`);\n                }\n                // rewrite the first entry to be able to directly set the state as\n                // well as any other path\n                path[0] = '$state';\n                isTimelineActive = false;\n                payload.set(store, path, payload.state.value);\n                isTimelineActive = true;\n            }\n        });\n    });\n}\nfunction addStoreToDevtools(app, store) {\n    if (!componentStateTypes.includes(getStoreType(store.$id))) {\n        componentStateTypes.push(getStoreType(store.$id));\n    }\n    setupDevtoolsPlugin({\n        id: 'dev.esm.pinia',\n        label: 'Pinia 🍍',\n        logo: 'https://pinia.vuejs.org/logo.svg',\n        packageName: 'pinia',\n        homepage: 'https://pinia.vuejs.org',\n        componentStateTypes,\n        app,\n        settings: {\n            logStoreChanges: {\n                label: 'Notify about new/deleted stores',\n                type: 'boolean',\n                defaultValue: true,\n            },\n            // useEmojis: {\n            //   label: 'Use emojis in messages ⚡️',\n            //   type: 'boolean',\n            //   defaultValue: true,\n            // },\n        },\n    }, (api) => {\n        // gracefully handle errors\n        const now = typeof api.now === 'function' ? api.now.bind(api) : Date.now;\n        store.$onAction(({ after, onError, name, args }) => {\n            const groupId = runningActionId++;\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: {\n                    time: now(),\n                    title: '🛫 ' + name,\n                    subtitle: 'start',\n                    data: {\n                        store: formatDisplay(store.$id),\n                        action: formatDisplay(name),\n                        args,\n                    },\n                    groupId,\n                },\n            });\n            after((result) => {\n                activeAction = undefined;\n                api.addTimelineEvent({\n                    layerId: MUTATIONS_LAYER_ID,\n                    event: {\n                        time: now(),\n                        title: '🛬 ' + name,\n                        subtitle: 'end',\n                        data: {\n                            store: formatDisplay(store.$id),\n                            action: formatDisplay(name),\n                            args,\n                            result,\n                        },\n                        groupId,\n                    },\n                });\n            });\n            onError((error) => {\n                activeAction = undefined;\n                api.addTimelineEvent({\n                    layerId: MUTATIONS_LAYER_ID,\n                    event: {\n                        time: now(),\n                        logType: 'error',\n                        title: '💥 ' + name,\n                        subtitle: 'end',\n                        data: {\n                            store: formatDisplay(store.$id),\n                            action: formatDisplay(name),\n                            args,\n                            error,\n                        },\n                        groupId,\n                    },\n                });\n            });\n        }, true);\n        store._customProperties.forEach((name) => {\n            watch(() => unref(store[name]), (newValue, oldValue) => {\n                api.notifyComponentUpdate();\n                api.sendInspectorState(INSPECTOR_ID);\n                if (isTimelineActive) {\n                    api.addTimelineEvent({\n                        layerId: MUTATIONS_LAYER_ID,\n                        event: {\n                            time: now(),\n                            title: 'Change',\n                            subtitle: name,\n                            data: {\n                                newValue,\n                                oldValue,\n                            },\n                            groupId: activeAction,\n                        },\n                    });\n                }\n            }, { deep: true });\n        });\n        store.$subscribe(({ events, type }, state) => {\n            api.notifyComponentUpdate();\n            api.sendInspectorState(INSPECTOR_ID);\n            if (!isTimelineActive)\n                return;\n            // rootStore.state[store.id] = state\n            const eventData = {\n                time: now(),\n                title: formatMutationType(type),\n                data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),\n                groupId: activeAction,\n            };\n            if (type === MutationType.patchFunction) {\n                eventData.subtitle = '⤵️';\n            }\n            else if (type === MutationType.patchObject) {\n                eventData.subtitle = '🧩';\n            }\n            else if (events && !Array.isArray(events)) {\n                eventData.subtitle = events.type;\n            }\n            if (events) {\n                eventData.data['rawEvent(s)'] = {\n                    _custom: {\n                        display: 'DebuggerEvent',\n                        type: 'object',\n                        tooltip: 'raw DebuggerEvent[]',\n                        value: events,\n                    },\n                };\n            }\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: eventData,\n            });\n        }, { detached: true, flush: 'sync' });\n        const hotUpdate = store._hotUpdate;\n        store._hotUpdate = markRaw((newStore) => {\n            hotUpdate(newStore);\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: {\n                    time: now(),\n                    title: '🔥 ' + store.$id,\n                    subtitle: 'HMR update',\n                    data: {\n                        store: formatDisplay(store.$id),\n                        info: formatDisplay(`HMR update`),\n                    },\n                },\n            });\n            // update the devtools too\n            api.notifyComponentUpdate();\n            api.sendInspectorTree(INSPECTOR_ID);\n            api.sendInspectorState(INSPECTOR_ID);\n        });\n        const { $dispose } = store;\n        store.$dispose = () => {\n            $dispose();\n            api.notifyComponentUpdate();\n            api.sendInspectorTree(INSPECTOR_ID);\n            api.sendInspectorState(INSPECTOR_ID);\n            api.getSettings().logStoreChanges &&\n                toastMessage(`Disposed \"${store.$id}\" store 🗑`);\n        };\n        // trigger an update so it can display new registered stores\n        api.notifyComponentUpdate();\n        api.sendInspectorTree(INSPECTOR_ID);\n        api.sendInspectorState(INSPECTOR_ID);\n        api.getSettings().logStoreChanges &&\n            toastMessage(`\"${store.$id}\" store installed 🆕`);\n    });\n}\nlet runningActionId = 0;\nlet activeAction;\n/**\n * Patches a store to enable action grouping in devtools by wrapping the store with a Proxy that is passed as the\n * context of all actions, allowing us to set `runningAction` on each access and effectively associating any state\n * mutation to the action.\n *\n * @param store - store to patch\n * @param actionNames - list of actionst to patch\n */\nfunction patchActionForGrouping(store, actionNames, wrapWithProxy) {\n    // original actions of the store as they are given by pinia. We are going to override them\n    const actions = actionNames.reduce((storeActions, actionName) => {\n        // use toRaw to avoid tracking #541\n        storeActions[actionName] = toRaw(store)[actionName];\n        return storeActions;\n    }, {});\n    for (const actionName in actions) {\n        store[actionName] = function () {\n            // the running action id is incremented in a before action hook\n            const _actionId = runningActionId;\n            const trackedStore = wrapWithProxy\n                ? new Proxy(store, {\n                    get(...args) {\n                        activeAction = _actionId;\n                        return Reflect.get(...args);\n                    },\n                    set(...args) {\n                        activeAction = _actionId;\n                        return Reflect.set(...args);\n                    },\n                })\n                : store;\n            // For Setup Stores we need https://github.com/tc39/proposal-async-context\n            activeAction = _actionId;\n            const retValue = actions[actionName].apply(trackedStore, arguments);\n            // this is safer as async actions in Setup Stores would associate mutations done outside of the action\n            activeAction = undefined;\n            return retValue;\n        };\n    }\n}\n/**\n * pinia.use(devtoolsPlugin)\n */\nfunction devtoolsPlugin({ app, store, options }) {\n    // HMR module\n    if (store.$id.startsWith('__hot:')) {\n        return;\n    }\n    // detect option api vs setup api\n    store._isOptionsAPI = !!options.state;\n    patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);\n    // Upgrade the HMR to also update the new actions\n    const originalHotUpdate = store._hotUpdate;\n    toRaw(store)._hotUpdate = function (newStore) {\n        originalHotUpdate.apply(this, arguments);\n        patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);\n    };\n    addStoreToDevtools(app, \n    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?\n    store);\n}\n\n/**\n * Creates a Pinia instance to be used by the application\n */\nfunction createPinia() {\n    const scope = effectScope(true);\n    // NOTE: here we could check the window object for a state and directly set it\n    // if there is anything like it with Vue 3 SSR\n    const state = scope.run(() => ref({}));\n    let _p = [];\n    // plugins added before calling app.use(pinia)\n    let toBeInstalled = [];\n    const pinia = markRaw({\n        install(app) {\n            // this allows calling useStore() outside of a component setup after\n            // installing pinia's plugin\n            setActivePinia(pinia);\n            if (!isVue2) {\n                pinia._a = app;\n                app.provide(piniaSymbol, pinia);\n                app.config.globalProperties.$pinia = pinia;\n                /* istanbul ignore else */\n                if (USE_DEVTOOLS) {\n                    registerPiniaDevtools(app, pinia);\n                }\n                toBeInstalled.forEach((plugin) => _p.push(plugin));\n                toBeInstalled = [];\n            }\n        },\n        use(plugin) {\n            if (!this._a && !isVue2) {\n                toBeInstalled.push(plugin);\n            }\n            else {\n                _p.push(plugin);\n            }\n            return this;\n        },\n        _p,\n        // it's actually undefined here\n        // @ts-expect-error\n        _a: null,\n        _e: scope,\n        _s: new Map(),\n        state,\n    });\n    // pinia devtools rely on dev only features so they cannot be forced unless\n    // the dev build of Vue is used. Avoid old browsers like IE11.\n    if (USE_DEVTOOLS && typeof Proxy !== 'undefined') {\n        pinia.use(devtoolsPlugin);\n    }\n    return pinia;\n}\n\n/**\n * Checks if a function is a `StoreDefinition`.\n *\n * @param fn - object to test\n * @returns true if `fn` is a StoreDefinition\n */\nconst isUseStore = (fn) => {\n    return typeof fn === 'function' && typeof fn.$id === 'string';\n};\n/**\n * Mutates in place `newState` with `oldState` to _hot update_ it. It will\n * remove any key not existing in `newState` and recursively merge plain\n * objects.\n *\n * @param newState - new state object to be patched\n * @param oldState - old state that should be used to patch newState\n * @returns - newState\n */\nfunction patchObject(newState, oldState) {\n    // no need to go through symbols because they cannot be serialized anyway\n    for (const key in oldState) {\n        const subPatch = oldState[key];\n        // skip the whole sub tree\n        if (!(key in newState)) {\n            continue;\n        }\n        const targetValue = newState[key];\n        if (isPlainObject(targetValue) &&\n            isPlainObject(subPatch) &&\n            !isRef(subPatch) &&\n            !isReactive(subPatch)) {\n            newState[key] = patchObject(targetValue, subPatch);\n        }\n        else {\n            // objects are either a bit more complex (e.g. refs) or primitives, so we\n            // just set the whole thing\n            if (isVue2) {\n                set(newState, key, subPatch);\n            }\n            else {\n                newState[key] = subPatch;\n            }\n        }\n    }\n    return newState;\n}\n/**\n * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.\n *\n * @example\n * ```js\n * const useUser = defineStore(...)\n * if (import.meta.hot) {\n *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))\n * }\n * ```\n *\n * @param initialUseStore - return of the defineStore to hot update\n * @param hot - `import.meta.hot`\n */\nfunction acceptHMRUpdate(initialUseStore, hot) {\n    // strip as much as possible from iife.prod\n    if (!(process.env.NODE_ENV !== 'production')) {\n        return () => { };\n    }\n    return (newModule) => {\n        const pinia = hot.data.pinia || initialUseStore._pinia;\n        if (!pinia) {\n            // this store is still not used\n            return;\n        }\n        // preserve the pinia instance across loads\n        hot.data.pinia = pinia;\n        // console.log('got data', newStore)\n        for (const exportName in newModule) {\n            const useStore = newModule[exportName];\n            // console.log('checking for', exportName)\n            if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {\n                // console.log('Accepting update for', useStore.$id)\n                const id = useStore.$id;\n                if (id !== initialUseStore.$id) {\n                    console.warn(`The id of the store changed from \"${initialUseStore.$id}\" to \"${id}\". Reloading.`);\n                    // return import.meta.hot.invalidate()\n                    return hot.invalidate();\n                }\n                const existingStore = pinia._s.get(id);\n                if (!existingStore) {\n                    console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);\n                    return;\n                }\n                useStore(pinia, existingStore);\n            }\n        }\n    };\n}\n\nconst noop = () => { };\nfunction addSubscription(subscriptions, callback, detached, onCleanup = noop) {\n    subscriptions.push(callback);\n    const removeSubscription = () => {\n        const idx = subscriptions.indexOf(callback);\n        if (idx > -1) {\n            subscriptions.splice(idx, 1);\n            onCleanup();\n        }\n    };\n    if (!detached && getCurrentScope()) {\n        onScopeDispose(removeSubscription);\n    }\n    return removeSubscription;\n}\nfunction triggerSubscriptions(subscriptions, ...args) {\n    subscriptions.slice().forEach((callback) => {\n        callback(...args);\n    });\n}\n\nconst fallbackRunWithContext = (fn) => fn();\nfunction mergeReactiveObjects(target, patchToApply) {\n    // Handle Map instances\n    if (target instanceof Map && patchToApply instanceof Map) {\n        patchToApply.forEach((value, key) => target.set(key, value));\n    }\n    // Handle Set instances\n    if (target instanceof Set && patchToApply instanceof Set) {\n        patchToApply.forEach(target.add, target);\n    }\n    // no need to go through symbols because they cannot be serialized anyway\n    for (const key in patchToApply) {\n        if (!patchToApply.hasOwnProperty(key))\n            continue;\n        const subPatch = patchToApply[key];\n        const targetValue = target[key];\n        if (isPlainObject(targetValue) &&\n            isPlainObject(subPatch) &&\n            target.hasOwnProperty(key) &&\n            !isRef(subPatch) &&\n            !isReactive(subPatch)) {\n            // NOTE: here I wanted to warn about inconsistent types but it's not possible because in setup stores one might\n            // start the value of a property as a certain type e.g. a Map, and then for some reason, during SSR, change that\n            // to `undefined`. When trying to hydrate, we want to override the Map with `undefined`.\n            target[key] = mergeReactiveObjects(targetValue, subPatch);\n        }\n        else {\n            // @ts-expect-error: subPatch is a valid value\n            target[key] = subPatch;\n        }\n    }\n    return target;\n}\nconst skipHydrateSymbol = (process.env.NODE_ENV !== 'production')\n    ? Symbol('pinia:skipHydration')\n    : /* istanbul ignore next */ Symbol();\nconst skipHydrateMap = /*#__PURE__*/ new WeakMap();\n/**\n * Tells Pinia to skip the hydration process of a given object. This is useful in setup stores (only) when you return a\n * stateful object in the store but it isn't really state. e.g. returning a router instance in a setup store.\n *\n * @param obj - target object\n * @returns obj\n */\nfunction skipHydrate(obj) {\n    return isVue2\n        ? // in @vue/composition-api, the refs are sealed so defineProperty doesn't work...\n            /* istanbul ignore next */ skipHydrateMap.set(obj, 1) && obj\n        : Object.defineProperty(obj, skipHydrateSymbol, {});\n}\n/**\n * Returns whether a value should be hydrated\n *\n * @param obj - target variable\n * @returns true if `obj` should be hydrated\n */\nfunction shouldHydrate(obj) {\n    return isVue2\n        ? /* istanbul ignore next */ !skipHydrateMap.has(obj)\n        : !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);\n}\nconst { assign } = Object;\nfunction isComputed(o) {\n    return !!(isRef(o) && o.effect);\n}\nfunction createOptionsStore(id, options, pinia, hot) {\n    const { state, actions, getters } = options;\n    const initialState = pinia.state.value[id];\n    let store;\n    function setup() {\n        if (!initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\n            /* istanbul ignore if */\n            if (isVue2) {\n                set(pinia.state.value, id, state ? state() : {});\n            }\n            else {\n                pinia.state.value[id] = state ? state() : {};\n            }\n        }\n        // avoid creating a state in pinia.state.value\n        const localState = (process.env.NODE_ENV !== 'production') && hot\n            ? // use ref() to unwrap refs inside state TODO: check if this is still necessary\n                toRefs(ref(state ? state() : {}).value)\n            : toRefs(pinia.state.value[id]);\n        return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {\n            if ((process.env.NODE_ENV !== 'production') && name in localState) {\n                console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with \"${name}\" in store \"${id}\".`);\n            }\n            computedGetters[name] = markRaw(computed(() => {\n                setActivePinia(pinia);\n                // it was created just before\n                const store = pinia._s.get(id);\n                // allow cross using stores\n                /* istanbul ignore next */\n                if (isVue2 && !store._r)\n                    return;\n                // @ts-expect-error\n                // return getters![name].call(context, context)\n                // TODO: avoid reading the getter while assigning with a global variable\n                return getters[name].call(store, store);\n            }));\n            return computedGetters;\n        }, {}));\n    }\n    store = createSetupStore(id, setup, options, pinia, hot, true);\n    return store;\n}\nfunction createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {\n    let scope;\n    const optionsForPlugin = assign({ actions: {} }, options);\n    /* istanbul ignore if */\n    if ((process.env.NODE_ENV !== 'production') && !pinia._e.active) {\n        throw new Error('Pinia destroyed');\n    }\n    // watcher options for $subscribe\n    const $subscribeOptions = {\n        deep: true,\n        // flush: 'post',\n    };\n    /* istanbul ignore else */\n    if ((process.env.NODE_ENV !== 'production') && !isVue2) {\n        $subscribeOptions.onTrigger = (event) => {\n            /* istanbul ignore else */\n            if (isListening) {\n                debuggerEvents = event;\n                // avoid triggering this while the store is being built and the state is being set in pinia\n            }\n            else if (isListening == false && !store._hotUpdating) {\n                // let patch send all the events together later\n                /* istanbul ignore else */\n                if (Array.isArray(debuggerEvents)) {\n                    debuggerEvents.push(event);\n                }\n                else {\n                    console.error('🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug.');\n                }\n            }\n        };\n    }\n    // internal state\n    let isListening; // set to true at the end\n    let isSyncListening; // set to true at the end\n    let subscriptions = [];\n    let actionSubscriptions = [];\n    let debuggerEvents;\n    const initialState = pinia.state.value[$id];\n    // avoid setting the state for option stores if it is set\n    // by the setup\n    if (!isOptionsStore && !initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\n        /* istanbul ignore if */\n        if (isVue2) {\n            set(pinia.state.value, $id, {});\n        }\n        else {\n            pinia.state.value[$id] = {};\n        }\n    }\n    const hotState = ref({});\n    // avoid triggering too many listeners\n    // https://github.com/vuejs/pinia/issues/1129\n    let activeListener;\n    function $patch(partialStateOrMutator) {\n        let subscriptionMutation;\n        isListening = isSyncListening = false;\n        // reset the debugger events since patches are sync\n        /* istanbul ignore else */\n        if ((process.env.NODE_ENV !== 'production')) {\n            debuggerEvents = [];\n        }\n        if (typeof partialStateOrMutator === 'function') {\n            partialStateOrMutator(pinia.state.value[$id]);\n            subscriptionMutation = {\n                type: MutationType.patchFunction,\n                storeId: $id,\n                events: debuggerEvents,\n            };\n        }\n        else {\n            mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);\n            subscriptionMutation = {\n                type: MutationType.patchObject,\n                payload: partialStateOrMutator,\n                storeId: $id,\n                events: debuggerEvents,\n            };\n        }\n        const myListenerId = (activeListener = Symbol());\n        nextTick().then(() => {\n            if (activeListener === myListenerId) {\n                isListening = true;\n            }\n        });\n        isSyncListening = true;\n        // because we paused the watcher, we need to manually call the subscriptions\n        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);\n    }\n    const $reset = isOptionsStore\n        ? function $reset() {\n            const { state } = options;\n            const newState = state ? state() : {};\n            // we use a patch to group all changes into one single subscription\n            this.$patch(($state) => {\n                assign($state, newState);\n            });\n        }\n        : /* istanbul ignore next */\n            (process.env.NODE_ENV !== 'production')\n                ? () => {\n                    throw new Error(`🍍: Store \"${$id}\" is built using the setup syntax and does not implement $reset().`);\n                }\n                : noop;\n    function $dispose() {\n        scope.stop();\n        subscriptions = [];\n        actionSubscriptions = [];\n        pinia._s.delete($id);\n    }\n    /**\n     * Wraps an action to handle subscriptions.\n     *\n     * @param name - name of the action\n     * @param action - action to wrap\n     * @returns a wrapped action to handle subscriptions\n     */\n    function wrapAction(name, action) {\n        return function () {\n            setActivePinia(pinia);\n            const args = Array.from(arguments);\n            const afterCallbackList = [];\n            const onErrorCallbackList = [];\n            function after(callback) {\n                afterCallbackList.push(callback);\n            }\n            function onError(callback) {\n                onErrorCallbackList.push(callback);\n            }\n            // @ts-expect-error\n            triggerSubscriptions(actionSubscriptions, {\n                args,\n                name,\n                store,\n                after,\n                onError,\n            });\n            let ret;\n            try {\n                ret = action.apply(this && this.$id === $id ? this : store, args);\n                // handle sync errors\n            }\n            catch (error) {\n                triggerSubscriptions(onErrorCallbackList, error);\n                throw error;\n            }\n            if (ret instanceof Promise) {\n                return ret\n                    .then((value) => {\n                    triggerSubscriptions(afterCallbackList, value);\n                    return value;\n                })\n                    .catch((error) => {\n                    triggerSubscriptions(onErrorCallbackList, error);\n                    return Promise.reject(error);\n                });\n            }\n            // trigger after callbacks\n            triggerSubscriptions(afterCallbackList, ret);\n            return ret;\n        };\n    }\n    const _hmrPayload = /*#__PURE__*/ markRaw({\n        actions: {},\n        getters: {},\n        state: [],\n        hotState,\n    });\n    const partialStore = {\n        _p: pinia,\n        // _s: scope,\n        $id,\n        $onAction: addSubscription.bind(null, actionSubscriptions),\n        $patch,\n        $reset,\n        $subscribe(callback, options = {}) {\n            const removeSubscription = addSubscription(subscriptions, callback, options.detached, () => stopWatcher());\n            const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {\n                if (options.flush === 'sync' ? isSyncListening : isListening) {\n                    callback({\n                        storeId: $id,\n                        type: MutationType.direct,\n                        events: debuggerEvents,\n                    }, state);\n                }\n            }, assign({}, $subscribeOptions, options)));\n            return removeSubscription;\n        },\n        $dispose,\n    };\n    /* istanbul ignore if */\n    if (isVue2) {\n        // start as non ready\n        partialStore._r = false;\n    }\n    const store = reactive((process.env.NODE_ENV !== 'production') || USE_DEVTOOLS\n        ? assign({\n            _hmrPayload,\n            _customProperties: markRaw(new Set()), // devtools custom properties\n        }, partialStore\n        // must be added later\n        // setupStore\n        )\n        : partialStore);\n    // store the partial store now so the setup of stores can instantiate each other before they are finished without\n    // creating infinite loops.\n    pinia._s.set($id, store);\n    const runWithContext = (pinia._a && pinia._a.runWithContext) || fallbackRunWithContext;\n    // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped\n    const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(setup)));\n    // overwrite existing actions to support $onAction\n    for (const key in setupStore) {\n        const prop = setupStore[key];\n        if ((isRef(prop) && !isComputed(prop)) || isReactive(prop)) {\n            // mark it as a piece of state to be serialized\n            if ((process.env.NODE_ENV !== 'production') && hot) {\n                set(hotState.value, key, toRef(setupStore, key));\n                // createOptionStore directly sets the state in pinia.state.value so we\n                // can just skip that\n            }\n            else if (!isOptionsStore) {\n                // in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created\n                if (initialState && shouldHydrate(prop)) {\n                    if (isRef(prop)) {\n                        prop.value = initialState[key];\n                    }\n                    else {\n                        // probably a reactive object, lets recursively assign\n                        // @ts-expect-error: prop is unknown\n                        mergeReactiveObjects(prop, initialState[key]);\n                    }\n                }\n                // transfer the ref to the pinia state to keep everything in sync\n                /* istanbul ignore if */\n                if (isVue2) {\n                    set(pinia.state.value[$id], key, prop);\n                }\n                else {\n                    pinia.state.value[$id][key] = prop;\n                }\n            }\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                _hmrPayload.state.push(key);\n            }\n            // action\n        }\n        else if (typeof prop === 'function') {\n            // @ts-expect-error: we are overriding the function we avoid wrapping if\n            const actionValue = (process.env.NODE_ENV !== 'production') && hot ? prop : wrapAction(key, prop);\n            // this a hot module replacement store because the hotUpdate method needs\n            // to do it with the right context\n            /* istanbul ignore if */\n            if (isVue2) {\n                set(setupStore, key, actionValue);\n            }\n            else {\n                // @ts-expect-error\n                setupStore[key] = actionValue;\n            }\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                _hmrPayload.actions[key] = prop;\n            }\n            // list actions so they can be used in plugins\n            // @ts-expect-error\n            optionsForPlugin.actions[key] = prop;\n        }\n        else if ((process.env.NODE_ENV !== 'production')) {\n            // add getters for devtools\n            if (isComputed(prop)) {\n                _hmrPayload.getters[key] = isOptionsStore\n                    ? // @ts-expect-error\n                        options.getters[key]\n                    : prop;\n                if (IS_CLIENT) {\n                    const getters = setupStore._getters ||\n                        // @ts-expect-error: same\n                        (setupStore._getters = markRaw([]));\n                    getters.push(key);\n                }\n            }\n        }\n    }\n    // add the state, getters, and action properties\n    /* istanbul ignore if */\n    if (isVue2) {\n        Object.keys(setupStore).forEach((key) => {\n            set(store, key, setupStore[key]);\n        });\n    }\n    else {\n        assign(store, setupStore);\n        // allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.\n        // Make `storeToRefs()` work with `reactive()` #799\n        assign(toRaw(store), setupStore);\n    }\n    // use this instead of a computed with setter to be able to create it anywhere\n    // without linking the computed lifespan to wherever the store is first\n    // created.\n    Object.defineProperty(store, '$state', {\n        get: () => ((process.env.NODE_ENV !== 'production') && hot ? hotState.value : pinia.state.value[$id]),\n        set: (state) => {\n            /* istanbul ignore if */\n            if ((process.env.NODE_ENV !== 'production') && hot) {\n                throw new Error('cannot set hotState');\n            }\n            $patch(($state) => {\n                assign($state, state);\n            });\n        },\n    });\n    // add the hotUpdate before plugins to allow them to override it\n    /* istanbul ignore else */\n    if ((process.env.NODE_ENV !== 'production')) {\n        store._hotUpdate = markRaw((newStore) => {\n            store._hotUpdating = true;\n            newStore._hmrPayload.state.forEach((stateKey) => {\n                if (stateKey in store.$state) {\n                    const newStateTarget = newStore.$state[stateKey];\n                    const oldStateSource = store.$state[stateKey];\n                    if (typeof newStateTarget === 'object' &&\n                        isPlainObject(newStateTarget) &&\n                        isPlainObject(oldStateSource)) {\n                        patchObject(newStateTarget, oldStateSource);\n                    }\n                    else {\n                        // transfer the ref\n                        newStore.$state[stateKey] = oldStateSource;\n                    }\n                }\n                // patch direct access properties to allow store.stateProperty to work as\n                // store.$state.stateProperty\n                set(store, stateKey, toRef(newStore.$state, stateKey));\n            });\n            // remove deleted state properties\n            Object.keys(store.$state).forEach((stateKey) => {\n                if (!(stateKey in newStore.$state)) {\n                    del(store, stateKey);\n                }\n            });\n            // avoid devtools logging this as a mutation\n            isListening = false;\n            isSyncListening = false;\n            pinia.state.value[$id] = toRef(newStore._hmrPayload, 'hotState');\n            isSyncListening = true;\n            nextTick().then(() => {\n                isListening = true;\n            });\n            for (const actionName in newStore._hmrPayload.actions) {\n                const action = newStore[actionName];\n                set(store, actionName, wrapAction(actionName, action));\n            }\n            // TODO: does this work in both setup and option store?\n            for (const getterName in newStore._hmrPayload.getters) {\n                const getter = newStore._hmrPayload.getters[getterName];\n                const getterValue = isOptionsStore\n                    ? // special handling of options api\n                        computed(() => {\n                            setActivePinia(pinia);\n                            return getter.call(store, store);\n                        })\n                    : getter;\n                set(store, getterName, getterValue);\n            }\n            // remove deleted getters\n            Object.keys(store._hmrPayload.getters).forEach((key) => {\n                if (!(key in newStore._hmrPayload.getters)) {\n                    del(store, key);\n                }\n            });\n            // remove old actions\n            Object.keys(store._hmrPayload.actions).forEach((key) => {\n                if (!(key in newStore._hmrPayload.actions)) {\n                    del(store, key);\n                }\n            });\n            // update the values used in devtools and to allow deleting new properties later on\n            store._hmrPayload = newStore._hmrPayload;\n            store._getters = newStore._getters;\n            store._hotUpdating = false;\n        });\n    }\n    if (USE_DEVTOOLS) {\n        const nonEnumerable = {\n            writable: true,\n            configurable: true,\n            // avoid warning on devtools trying to display this property\n            enumerable: false,\n        };\n        ['_p', '_hmrPayload', '_getters', '_customProperties'].forEach((p) => {\n            Object.defineProperty(store, p, assign({ value: store[p] }, nonEnumerable));\n        });\n    }\n    /* istanbul ignore if */\n    if (isVue2) {\n        // mark the store as ready before plugins\n        store._r = true;\n    }\n    // apply all plugins\n    pinia._p.forEach((extender) => {\n        /* istanbul ignore else */\n        if (USE_DEVTOOLS) {\n            const extensions = scope.run(() => extender({\n                store,\n                app: pinia._a,\n                pinia,\n                options: optionsForPlugin,\n            }));\n            Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));\n            assign(store, extensions);\n        }\n        else {\n            assign(store, scope.run(() => extender({\n                store,\n                app: pinia._a,\n                pinia,\n                options: optionsForPlugin,\n            })));\n        }\n    });\n    if ((process.env.NODE_ENV !== 'production') &&\n        store.$state &&\n        typeof store.$state === 'object' &&\n        typeof store.$state.constructor === 'function' &&\n        !store.$state.constructor.toString().includes('[native code]')) {\n        console.warn(`[🍍]: The \"state\" must be a plain object. It cannot be\\n` +\n            `\\tstate: () => new MyClass()\\n` +\n            `Found in store \"${store.$id}\".`);\n    }\n    // only apply hydrate to option stores with an initial state in pinia\n    if (initialState &&\n        isOptionsStore &&\n        options.hydrate) {\n        options.hydrate(store.$state, initialState);\n    }\n    isListening = true;\n    isSyncListening = true;\n    return store;\n}\nfunction defineStore(\n// TODO: add proper types from above\nidOrOptions, setup, setupOptions) {\n    let id;\n    let options;\n    const isSetupStore = typeof setup === 'function';\n    if (typeof idOrOptions === 'string') {\n        id = idOrOptions;\n        // the option store setup will contain the actual options in this case\n        options = isSetupStore ? setupOptions : setup;\n    }\n    else {\n        options = idOrOptions;\n        id = idOrOptions.id;\n        if ((process.env.NODE_ENV !== 'production') && typeof id !== 'string') {\n            throw new Error(`[🍍]: \"defineStore()\" must be passed a store id as its first argument.`);\n        }\n    }\n    function useStore(pinia, hot) {\n        const hasContext = hasInjectionContext();\n        pinia =\n            // in test mode, ignore the argument provided as we can always retrieve a\n            // pinia instance with getActivePinia()\n            ((process.env.NODE_ENV === 'test') && activePinia && activePinia._testing ? null : pinia) ||\n                (hasContext ? inject(piniaSymbol, null) : null);\n        if (pinia)\n            setActivePinia(pinia);\n        if ((process.env.NODE_ENV !== 'production') && !activePinia) {\n            throw new Error(`[🍍]: \"getActivePinia()\" was called but there was no active Pinia. Are you trying to use a store before calling \"app.use(pinia)\"?\\n` +\n                `See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.\\n` +\n                `This will fail in production.`);\n        }\n        pinia = activePinia;\n        if (!pinia._s.has(id)) {\n            // creating the store registers it in `pinia._s`\n            if (isSetupStore) {\n                createSetupStore(id, setup, options, pinia);\n            }\n            else {\n                createOptionsStore(id, options, pinia);\n            }\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                // @ts-expect-error: not the right inferred type\n                useStore._pinia = pinia;\n            }\n        }\n        const store = pinia._s.get(id);\n        if ((process.env.NODE_ENV !== 'production') && hot) {\n            const hotId = '__hot:' + id;\n            const newStore = isSetupStore\n                ? createSetupStore(hotId, setup, options, pinia, true)\n                : createOptionsStore(hotId, assign({}, options), pinia, true);\n            hot._hotUpdate(newStore);\n            // cleanup the state properties and the store from the cache\n            delete pinia.state.value[hotId];\n            pinia._s.delete(hotId);\n        }\n        if ((process.env.NODE_ENV !== 'production') && IS_CLIENT) {\n            const currentInstance = getCurrentInstance();\n            // save stores in instances to access them devtools\n            if (currentInstance &&\n                currentInstance.proxy &&\n                // avoid adding stores that are just built for hot module replacement\n                !hot) {\n                const vm = currentInstance.proxy;\n                const cache = '_pStores' in vm ? vm._pStores : (vm._pStores = {});\n                cache[id] = store;\n            }\n        }\n        // StoreGeneric cannot be casted towards Store\n        return store;\n    }\n    useStore.$id = id;\n    return useStore;\n}\n\nlet mapStoreSuffix = 'Store';\n/**\n * Changes the suffix added by `mapStores()`. Can be set to an empty string.\n * Defaults to `\"Store\"`. Make sure to extend the MapStoresCustomization\n * interface if you are using TypeScript.\n *\n * @param suffix - new suffix\n */\nfunction setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS\n) {\n    mapStoreSuffix = suffix;\n}\n/**\n * Allows using stores without the composition API (`setup()`) by generating an\n * object to be spread in the `computed` field of a component. It accepts a list\n * of store definitions.\n *\n * @example\n * ```js\n * export default {\n *   computed: {\n *     // other computed properties\n *     ...mapStores(useUserStore, useCartStore)\n *   },\n *\n *   created() {\n *     this.userStore // store with id \"user\"\n *     this.cartStore // store with id \"cart\"\n *   }\n * }\n * ```\n *\n * @param stores - list of stores to map to an object\n */\nfunction mapStores(...stores) {\n    if ((process.env.NODE_ENV !== 'production') && Array.isArray(stores[0])) {\n        console.warn(`[🍍]: Directly pass all stores to \"mapStores()\" without putting them in an array:\\n` +\n            `Replace\\n` +\n            `\\tmapStores([useAuthStore, useCartStore])\\n` +\n            `with\\n` +\n            `\\tmapStores(useAuthStore, useCartStore)\\n` +\n            `This will fail in production if not fixed.`);\n        stores = stores[0];\n    }\n    return stores.reduce((reduced, useStore) => {\n        // @ts-expect-error: $id is added by defineStore\n        reduced[useStore.$id + mapStoreSuffix] = function () {\n            return useStore(this.$pinia);\n        };\n        return reduced;\n    }, {});\n}\n/**\n * Allows using state and getters from one store without using the composition\n * API (`setup()`) by generating an object to be spread in the `computed` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapState(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            reduced[key] = function () {\n                return useStore(this.$pinia)[key];\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function () {\n                const store = useStore(this.$pinia);\n                const storeKey = keysOrMapper[key];\n                // for some reason TS is unable to infer the type of storeKey to be a\n                // function\n                return typeof storeKey === 'function'\n                    ? storeKey.call(this, store)\n                    : store[storeKey];\n            };\n            return reduced;\n        }, {});\n}\n/**\n * Alias for `mapState()`. You should use `mapState()` instead.\n * @deprecated use `mapState()` instead.\n */\nconst mapGetters = mapState;\n/**\n * Allows directly using actions from your store without using the composition\n * API (`setup()`) by generating an object to be spread in the `methods` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapActions(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function (...args) {\n                return useStore(this.$pinia)[key](...args);\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function (...args) {\n                return useStore(this.$pinia)[keysOrMapper[key]](...args);\n            };\n            return reduced;\n        }, {});\n}\n/**\n * Allows using state and getters from one store without using the composition\n * API (`setup()`) by generating an object to be spread in the `computed` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapWritableState(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            // @ts-ignore\n            reduced[key] = {\n                get() {\n                    return useStore(this.$pinia)[key];\n                },\n                set(value) {\n                    // it's easier to type it here as any\n                    return (useStore(this.$pinia)[key] = value);\n                },\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            // @ts-ignore\n            reduced[key] = {\n                get() {\n                    return useStore(this.$pinia)[keysOrMapper[key]];\n                },\n                set(value) {\n                    // it's easier to type it here as any\n                    return (useStore(this.$pinia)[keysOrMapper[key]] = value);\n                },\n            };\n            return reduced;\n        }, {});\n}\n\n/**\n * Creates an object of references with all the state, getters, and plugin-added\n * state properties of the store. Similar to `toRefs()` but specifically\n * designed for Pinia stores so methods and non reactive properties are\n * completely ignored.\n *\n * @param store - store to extract the refs from\n */\nfunction storeToRefs(store) {\n    // See https://github.com/vuejs/pinia/issues/852\n    // It's easier to just use toRefs() even if it includes more stuff\n    if (isVue2) {\n        // @ts-expect-error: toRefs include methods and others\n        return toRefs(store);\n    }\n    else {\n        store = toRaw(store);\n        const refs = {};\n        for (const key in store) {\n            const value = store[key];\n            if (isRef(value) || isReactive(value)) {\n                // @ts-expect-error: the key is state or getter\n                refs[key] =\n                    // ---\n                    toRef(store, key);\n            }\n        }\n        return refs;\n    }\n}\n\n/**\n * Vue 2 Plugin that must be installed for pinia to work. Note **you don't need\n * this plugin if you are using Nuxt.js**. Use the `buildModule` instead:\n * https://pinia.vuejs.org/ssr/nuxt.html.\n *\n * @example\n * ```js\n * import Vue from 'vue'\n * import { PiniaVuePlugin, createPinia } from 'pinia'\n *\n * Vue.use(PiniaVuePlugin)\n * const pinia = createPinia()\n *\n * new Vue({\n *   el: '#app',\n *   // ...\n *   pinia,\n * })\n * ```\n *\n * @param _Vue - `Vue` imported from 'vue'.\n */\nconst PiniaVuePlugin = function (_Vue) {\n    // Equivalent of\n    // app.config.globalProperties.$pinia = pinia\n    _Vue.mixin({\n        beforeCreate() {\n            const options = this.$options;\n            if (options.pinia) {\n                const pinia = options.pinia;\n                // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/main/src/apis/inject.ts#L31\n                /* istanbul ignore else */\n                if (!this._provided) {\n                    const provideCache = {};\n                    Object.defineProperty(this, '_provided', {\n                        get: () => provideCache,\n                        set: (v) => Object.assign(provideCache, v),\n                    });\n                }\n                this._provided[piniaSymbol] = pinia;\n                // propagate the pinia instance in an SSR friendly way\n                // avoid adding it to nuxt twice\n                /* istanbul ignore else */\n                if (!this.$pinia) {\n                    this.$pinia = pinia;\n                }\n                pinia._a = this;\n                if (IS_CLIENT) {\n                    // this allows calling useStore() outside of a component setup after\n                    // installing pinia's plugin\n                    setActivePinia(pinia);\n                }\n                if (USE_DEVTOOLS) {\n                    registerPiniaDevtools(pinia._a, pinia);\n                }\n            }\n            else if (!this.$pinia && options.parent && options.parent.$pinia) {\n                this.$pinia = options.parent.$pinia;\n            }\n        },\n        destroyed() {\n            delete this._pStores;\n        },\n    });\n};\n\nexport { MutationType, PiniaVuePlugin, acceptHMRUpdate, createPinia, defineStore, getActivePinia, mapActions, mapGetters, mapState, mapStores, mapWritableState, setActivePinia, setMapStoreSuffix, skipHydrate, storeToRefs };\n","function flatHooks(configHooks, hooks = {}, parentName) {\n  for (const key in configHooks) {\n    const subHook = configHooks[key];\n    const name = parentName ? `${parentName}:${key}` : key;\n    if (typeof subHook === \"object\" && subHook !== null) {\n      flatHooks(subHook, hooks, name);\n    } else if (typeof subHook === \"function\") {\n      hooks[name] = subHook;\n    }\n  }\n  return hooks;\n}\nfunction mergeHooks(...hooks) {\n  const finalHooks = {};\n  for (const hook of hooks) {\n    const flatenHook = flatHooks(hook);\n    for (const key in flatenHook) {\n      if (finalHooks[key]) {\n        finalHooks[key].push(flatenHook[key]);\n      } else {\n        finalHooks[key] = [flatenHook[key]];\n      }\n    }\n  }\n  for (const key in finalHooks) {\n    if (finalHooks[key].length > 1) {\n      const array = finalHooks[key];\n      finalHooks[key] = (...arguments_) => serial(array, (function_) => function_(...arguments_));\n    } else {\n      finalHooks[key] = finalHooks[key][0];\n    }\n  }\n  return finalHooks;\n}\nfunction serial(tasks, function_) {\n  return tasks.reduce(\n    (promise, task) => promise.then(() => function_(task)),\n    Promise.resolve()\n  );\n}\nconst defaultTask = { run: (function_) => function_() };\nconst _createTask = () => defaultTask;\nconst createTask = typeof console.createTask !== \"undefined\" ? console.createTask : _createTask;\nfunction serialTaskCaller(hooks, args) {\n  const name = args.shift();\n  const task = createTask(name);\n  return hooks.reduce(\n    (promise, hookFunction) => promise.then(() => task.run(() => hookFunction(...args))),\n    Promise.resolve()\n  );\n}\nfunction parallelTaskCaller(hooks, args) {\n  const name = args.shift();\n  const task = createTask(name);\n  return Promise.all(hooks.map((hook) => task.run(() => hook(...args))));\n}\nfunction serialCaller(hooks, arguments_) {\n  return hooks.reduce(\n    (promise, hookFunction) => promise.then(() => hookFunction(...arguments_ || [])),\n    Promise.resolve()\n  );\n}\nfunction parallelCaller(hooks, args) {\n  return Promise.all(hooks.map((hook) => hook(...args || [])));\n}\nfunction callEachWith(callbacks, arg0) {\n  for (const callback of [...callbacks]) {\n    callback(arg0);\n  }\n}\n\nclass Hookable {\n  constructor() {\n    this._hooks = {};\n    this._before = void 0;\n    this._after = void 0;\n    this._deprecatedMessages = void 0;\n    this._deprecatedHooks = {};\n    this.hook = this.hook.bind(this);\n    this.callHook = this.callHook.bind(this);\n    this.callHookWith = this.callHookWith.bind(this);\n  }\n  hook(name, function_, options = {}) {\n    if (!name || typeof function_ !== \"function\") {\n      return () => {\n      };\n    }\n    const originalName = name;\n    let dep;\n    while (this._deprecatedHooks[name]) {\n      dep = this._deprecatedHooks[name];\n      name = dep.to;\n    }\n    if (dep && !options.allowDeprecated) {\n      let message = dep.message;\n      if (!message) {\n        message = `${originalName} hook has been deprecated` + (dep.to ? `, please use ${dep.to}` : \"\");\n      }\n      if (!this._deprecatedMessages) {\n        this._deprecatedMessages = /* @__PURE__ */ new Set();\n      }\n      if (!this._deprecatedMessages.has(message)) {\n        console.warn(message);\n        this._deprecatedMessages.add(message);\n      }\n    }\n    if (!function_.name) {\n      try {\n        Object.defineProperty(function_, \"name\", {\n          get: () => \"_\" + name.replace(/\\W+/g, \"_\") + \"_hook_cb\",\n          configurable: true\n        });\n      } catch {\n      }\n    }\n    this._hooks[name] = this._hooks[name] || [];\n    this._hooks[name].push(function_);\n    return () => {\n      if (function_) {\n        this.removeHook(name, function_);\n        function_ = void 0;\n      }\n    };\n  }\n  hookOnce(name, function_) {\n    let _unreg;\n    let _function = (...arguments_) => {\n      if (typeof _unreg === \"function\") {\n        _unreg();\n      }\n      _unreg = void 0;\n      _function = void 0;\n      return function_(...arguments_);\n    };\n    _unreg = this.hook(name, _function);\n    return _unreg;\n  }\n  removeHook(name, function_) {\n    if (this._hooks[name]) {\n      const index = this._hooks[name].indexOf(function_);\n      if (index !== -1) {\n        this._hooks[name].splice(index, 1);\n      }\n      if (this._hooks[name].length === 0) {\n        delete this._hooks[name];\n      }\n    }\n  }\n  deprecateHook(name, deprecated) {\n    this._deprecatedHooks[name] = typeof deprecated === \"string\" ? { to: deprecated } : deprecated;\n    const _hooks = this._hooks[name] || [];\n    delete this._hooks[name];\n    for (const hook of _hooks) {\n      this.hook(name, hook);\n    }\n  }\n  deprecateHooks(deprecatedHooks) {\n    Object.assign(this._deprecatedHooks, deprecatedHooks);\n    for (const name in deprecatedHooks) {\n      this.deprecateHook(name, deprecatedHooks[name]);\n    }\n  }\n  addHooks(configHooks) {\n    const hooks = flatHooks(configHooks);\n    const removeFns = Object.keys(hooks).map(\n      (key) => this.hook(key, hooks[key])\n    );\n    return () => {\n      for (const unreg of removeFns.splice(0, removeFns.length)) {\n        unreg();\n      }\n    };\n  }\n  removeHooks(configHooks) {\n    const hooks = flatHooks(configHooks);\n    for (const key in hooks) {\n      this.removeHook(key, hooks[key]);\n    }\n  }\n  removeAllHooks() {\n    for (const key in this._hooks) {\n      delete this._hooks[key];\n    }\n  }\n  callHook(name, ...arguments_) {\n    arguments_.unshift(name);\n    return this.callHookWith(serialTaskCaller, name, ...arguments_);\n  }\n  callHookParallel(name, ...arguments_) {\n    arguments_.unshift(name);\n    return this.callHookWith(parallelTaskCaller, name, ...arguments_);\n  }\n  callHookWith(caller, name, ...arguments_) {\n    const event = this._before || this._after ? { name, args: arguments_, context: {} } : void 0;\n    if (this._before) {\n      callEachWith(this._before, event);\n    }\n    const result = caller(\n      name in this._hooks ? [...this._hooks[name]] : [],\n      arguments_\n    );\n    if (result instanceof Promise) {\n      return result.finally(() => {\n        if (this._after && event) {\n          callEachWith(this._after, event);\n        }\n      });\n    }\n    if (this._after && event) {\n      callEachWith(this._after, event);\n    }\n    return result;\n  }\n  beforeEach(function_) {\n    this._before = this._before || [];\n    this._before.push(function_);\n    return () => {\n      if (this._before !== void 0) {\n        const index = this._before.indexOf(function_);\n        if (index !== -1) {\n          this._before.splice(index, 1);\n        }\n      }\n    };\n  }\n  afterEach(function_) {\n    this._after = this._after || [];\n    this._after.push(function_);\n    return () => {\n      if (this._after !== void 0) {\n        const index = this._after.indexOf(function_);\n        if (index !== -1) {\n          this._after.splice(index, 1);\n        }\n      }\n    };\n  }\n}\nfunction createHooks() {\n  return new Hookable();\n}\n\nconst isBrowser = typeof window !== \"undefined\";\nfunction createDebugger(hooks, _options = {}) {\n  const options = {\n    inspect: isBrowser,\n    group: isBrowser,\n    filter: () => true,\n    ..._options\n  };\n  const _filter = options.filter;\n  const filter = typeof _filter === \"string\" ? (name) => name.startsWith(_filter) : _filter;\n  const _tag = options.tag ? `[${options.tag}] ` : \"\";\n  const logPrefix = (event) => _tag + event.name + \"\".padEnd(event._id, \"\\0\");\n  const _idCtr = {};\n  const unsubscribeBefore = hooks.beforeEach((event) => {\n    if (filter !== void 0 && !filter(event.name)) {\n      return;\n    }\n    _idCtr[event.name] = _idCtr[event.name] || 0;\n    event._id = _idCtr[event.name]++;\n    console.time(logPrefix(event));\n  });\n  const unsubscribeAfter = hooks.afterEach((event) => {\n    if (filter !== void 0 && !filter(event.name)) {\n      return;\n    }\n    if (options.group) {\n      console.groupCollapsed(event.name);\n    }\n    if (options.inspect) {\n      console.timeLog(logPrefix(event), event.args);\n    } else {\n      console.timeEnd(logPrefix(event));\n    }\n    if (options.group) {\n      console.groupEnd();\n    }\n    _idCtr[event.name]--;\n  });\n  return {\n    /** Stop debugging and remove listeners */\n    close: () => {\n      unsubscribeBefore();\n      unsubscribeAfter();\n    }\n  };\n}\n\nexport { Hookable, createDebugger, createHooks, flatHooks, mergeHooks, parallelCaller, serial, serialCaller };\n","function asArray$1(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nconst SelfClosingTags = [\"meta\", \"link\", \"base\"];\nconst TagsWithInnerContent = [\"title\", \"titleTemplate\", \"script\", \"style\", \"noscript\"];\nconst HasElementTags = [\n  \"base\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\nconst ValidHeadTags = [\n  \"title\",\n  \"titleTemplate\",\n  \"templateParams\",\n  \"base\",\n  \"htmlAttrs\",\n  \"bodyAttrs\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\nconst UniqueTags = [\"base\", \"title\", \"titleTemplate\", \"bodyAttrs\", \"htmlAttrs\", \"templateParams\"];\nconst TagConfigKeys = [\"tagPosition\", \"tagPriority\", \"tagDuplicateStrategy\", \"children\", \"innerHTML\", \"textContent\", \"processTemplateParams\"];\nconst IsBrowser = typeof window !== \"undefined\";\nconst composableNames = [\n  \"getActiveHead\",\n  \"useHead\",\n  \"useSeoMeta\",\n  \"useHeadSafe\",\n  \"useServerHead\",\n  \"useServerSeoMeta\",\n  \"useServerHeadSafe\"\n];\n\nfunction defineHeadPlugin(plugin) {\n  return plugin;\n}\n\nfunction hashCode(s) {\n  let h = 9;\n  for (let i = 0; i < s.length; )\n    h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);\n  return ((h ^ h >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase();\n}\nfunction hashTag(tag) {\n  return tag._h || hashCode(tag._d ? tag._d : `${tag.tag}:${tag.textContent || tag.innerHTML || \"\"}:${Object.entries(tag.props).map(([key, value]) => `${key}:${String(value)}`).join(\",\")}`);\n}\n\nfunction tagDedupeKey(tag, fn) {\n  const { props, tag: tagName } = tag;\n  if (UniqueTags.includes(tagName))\n    return tagName;\n  if (tagName === \"link\" && props.rel === \"canonical\")\n    return \"canonical\";\n  if (props.charset)\n    return \"charset\";\n  const name = [\"id\"];\n  if (tagName === \"meta\")\n    name.push(...[\"name\", \"property\", \"http-equiv\"]);\n  for (const n of name) {\n    if (typeof props[n] !== \"undefined\") {\n      const val = String(props[n]);\n      if (fn && !fn(val))\n        return false;\n      return `${tagName}:${n}:${val}`;\n    }\n  }\n  return false;\n}\n\nfunction resolveTitleTemplate(template, title) {\n  if (template == null)\n    return title || null;\n  if (typeof template === \"function\")\n    return template(title);\n  return template;\n}\n\nfunction asArray(input) {\n  return Array.isArray(input) ? input : [input];\n}\nconst InternalKeySymbol = \"_$key\";\nfunction packObject(input, options) {\n  const keys = Object.keys(input);\n  let [k, v] = keys;\n  options = options || {};\n  options.key = options.key || k;\n  options.value = options.value || v;\n  options.resolveKey = options.resolveKey || ((k2) => k2);\n  const resolveKey = (index) => {\n    const arr = asArray(options[index]);\n    return arr.find((k2) => {\n      if (typeof k2 === \"string\" && k2.includes(\".\")) {\n        return k2;\n      }\n      return k2 && keys.includes(k2);\n    });\n  };\n  const resolveValue = (k2, input2) => {\n    if (k2.includes(\".\")) {\n      const paths = k2.split(\".\");\n      let val = input2;\n      for (const path of paths)\n        val = val[path];\n      return val;\n    }\n    return input2[k2];\n  };\n  k = resolveKey(\"key\") || k;\n  v = resolveKey(\"value\") || v;\n  const dedupeKeyPrefix = input.key ? `${InternalKeySymbol}${input.key}-` : \"\";\n  let keyValue = resolveValue(k, input);\n  keyValue = options.resolveKey(keyValue);\n  return {\n    [`${dedupeKeyPrefix}${keyValue}`]: resolveValue(v, input)\n  };\n}\n\nfunction packArray(input, options) {\n  const packed = {};\n  for (const i of input) {\n    const packedObj = packObject(i, options);\n    const pKey = Object.keys(packedObj)[0];\n    const isDedupeKey = pKey.startsWith(InternalKeySymbol);\n    if (!isDedupeKey && packed[pKey]) {\n      packed[pKey] = Array.isArray(packed[pKey]) ? packed[pKey] : [packed[pKey]];\n      packed[pKey].push(Object.values(packedObj)[0]);\n    } else {\n      packed[isDedupeKey ? pKey.split(\"-\").slice(1).join(\"-\") || pKey : pKey] = packedObj[pKey];\n    }\n  }\n  return packed;\n}\n\nfunction unpackToArray(input, options) {\n  const unpacked = [];\n  const kFn = options.resolveKeyData || ((ctx) => ctx.key);\n  const vFn = options.resolveValueData || ((ctx) => ctx.value);\n  for (const [k, v] of Object.entries(input)) {\n    unpacked.push(...(Array.isArray(v) ? v : [v]).map((i) => {\n      const ctx = { key: k, value: i };\n      const val = vFn(ctx);\n      if (typeof val === \"object\")\n        return unpackToArray(val, options);\n      if (Array.isArray(val))\n        return val;\n      return {\n        [typeof options.key === \"function\" ? options.key(ctx) : options.key]: kFn(ctx),\n        [typeof options.value === \"function\" ? options.value(ctx) : options.value]: val\n      };\n    }).flat());\n  }\n  return unpacked;\n}\n\nfunction unpackToString(value, options) {\n  return Object.entries(value).map(([key, value2]) => {\n    if (typeof value2 === \"object\")\n      value2 = unpackToString(value2, options);\n    if (options.resolve) {\n      const resolved = options.resolve({ key, value: value2 });\n      if (typeof resolved !== \"undefined\")\n        return resolved;\n    }\n    if (typeof value2 === \"number\")\n      value2 = value2.toString();\n    if (typeof value2 === \"string\" && options.wrapValue) {\n      value2 = value2.replace(new RegExp(options.wrapValue, \"g\"), `\\\\${options.wrapValue}`);\n      value2 = `${options.wrapValue}${value2}${options.wrapValue}`;\n    }\n    return `${key}${options.keyValueSeparator || \"\"}${value2}`;\n  }).join(options.entrySeparator || \"\");\n}\n\nconst p = (p2) => ({ keyValue: p2, metaKey: \"property\" });\nconst k = (p2) => ({ keyValue: p2 });\nconst MetaPackingSchema = {\n  appleItunesApp: {\n    unpack: {\n      entrySeparator: \", \",\n      resolve({ key, value }) {\n        return `${fixKeyCase(key)}=${value}`;\n      }\n    }\n  },\n  articleExpirationTime: p(\"article:expiration_time\"),\n  articleModifiedTime: p(\"article:modified_time\"),\n  articlePublishedTime: p(\"article:published_time\"),\n  bookReleaseDate: p(\"book:release_date\"),\n  charset: {\n    metaKey: \"charset\"\n  },\n  contentSecurityPolicy: {\n    unpack: {\n      entrySeparator: \"; \",\n      resolve({ key, value }) {\n        return `${fixKeyCase(key)} ${value}`;\n      }\n    },\n    metaKey: \"http-equiv\"\n  },\n  contentType: {\n    metaKey: \"http-equiv\"\n  },\n  defaultStyle: {\n    metaKey: \"http-equiv\"\n  },\n  fbAppId: p(\"fb:app_id\"),\n  msapplicationConfig: k(\"msapplication-Config\"),\n  msapplicationTileColor: k(\"msapplication-TileColor\"),\n  msapplicationTileImage: k(\"msapplication-TileImage\"),\n  ogAudioSecureUrl: p(\"og:audio:secure_url\"),\n  ogAudioUrl: p(\"og:audio\"),\n  ogImageSecureUrl: p(\"og:image:secure_url\"),\n  ogImageUrl: p(\"og:image\"),\n  ogSiteName: p(\"og:site_name\"),\n  ogVideoSecureUrl: p(\"og:video:secure_url\"),\n  ogVideoUrl: p(\"og:video\"),\n  profileFirstName: p(\"profile:first_name\"),\n  profileLastName: p(\"profile:last_name\"),\n  profileUsername: p(\"profile:username\"),\n  refresh: {\n    metaKey: \"http-equiv\",\n    unpack: {\n      entrySeparator: \";\",\n      resolve({ key, value }) {\n        if (key === \"seconds\")\n          return `${value}`;\n      }\n    }\n  },\n  robots: {\n    unpack: {\n      entrySeparator: \", \",\n      resolve({ key, value }) {\n        if (typeof value === \"boolean\")\n          return `${fixKeyCase(key)}`;\n        else\n          return `${fixKeyCase(key)}:${value}`;\n      }\n    }\n  },\n  xUaCompatible: {\n    metaKey: \"http-equiv\"\n  }\n};\nconst openGraphNamespaces = [\n  \"og\",\n  \"book\",\n  \"article\",\n  \"profile\"\n];\nfunction resolveMetaKeyType(key) {\n  const fKey = fixKeyCase(key).split(\":\")[0];\n  if (openGraphNamespaces.includes(fKey))\n    return \"property\";\n  return MetaPackingSchema[key]?.metaKey || \"name\";\n}\nfunction resolveMetaKeyValue(key) {\n  return MetaPackingSchema[key]?.keyValue || fixKeyCase(key);\n}\nfunction fixKeyCase(key) {\n  const updated = key.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n  const fKey = updated.split(\"-\")[0];\n  if (openGraphNamespaces.includes(fKey) || fKey === \"twitter\")\n    return key.replace(/([A-Z])/g, \":$1\").toLowerCase();\n  return updated;\n}\nfunction changeKeyCasingDeep(input) {\n  if (Array.isArray(input)) {\n    return input.map((entry) => changeKeyCasingDeep(entry));\n  }\n  if (typeof input !== \"object\" || Array.isArray(input))\n    return input;\n  const output = {};\n  for (const [key, value] of Object.entries(input))\n    output[fixKeyCase(key)] = changeKeyCasingDeep(value);\n  return output;\n}\nfunction resolvePackedMetaObjectValue(value, key) {\n  const definition = MetaPackingSchema[key];\n  if (key === \"refresh\")\n    return `${value.seconds};url=${value.url}`;\n  return unpackToString(\n    changeKeyCasingDeep(value),\n    {\n      keyValueSeparator: \"=\",\n      entrySeparator: \", \",\n      resolve({ value: value2, key: key2 }) {\n        if (value2 === null)\n          return \"\";\n        if (typeof value2 === \"boolean\")\n          return `${key2}`;\n      },\n      ...definition?.unpack\n    }\n  );\n}\nconst ObjectArrayEntries = [\"og:image\", \"og:video\", \"og:audio\", \"twitter:image\"];\nfunction sanitize(input) {\n  const out = {};\n  Object.entries(input).forEach(([k2, v]) => {\n    if (String(v) !== \"false\" && k2)\n      out[k2] = v;\n  });\n  return out;\n}\nfunction handleObjectEntry(key, v) {\n  const value = sanitize(v);\n  const fKey = fixKeyCase(key);\n  const attr = resolveMetaKeyType(fKey);\n  if (ObjectArrayEntries.includes(fKey)) {\n    const input = {};\n    Object.entries(value).forEach(([k2, v2]) => {\n      input[`${key}${k2 === \"url\" ? \"\" : `${k2.charAt(0).toUpperCase()}${k2.slice(1)}`}`] = v2;\n    });\n    return unpackMeta(input).sort((a, b) => (a[attr]?.length || 0) - (b[attr]?.length || 0));\n  }\n  return [{ [attr]: fKey, ...value }];\n}\nfunction unpackMeta(input) {\n  const extras = [];\n  const primitives = {};\n  Object.entries(input).forEach(([key, value]) => {\n    if (!Array.isArray(value)) {\n      if (typeof value === \"object\" && value) {\n        if (ObjectArrayEntries.includes(fixKeyCase(key))) {\n          extras.push(...handleObjectEntry(key, value));\n          return;\n        }\n        primitives[key] = sanitize(value);\n      } else {\n        primitives[key] = value;\n      }\n      return;\n    }\n    value.forEach((v) => {\n      extras.push(...typeof v === \"string\" ? unpackMeta({ [key]: v }) : handleObjectEntry(key, v));\n    });\n  });\n  const meta = unpackToArray(primitives, {\n    key({ key }) {\n      return resolveMetaKeyType(key);\n    },\n    value({ key }) {\n      return key === \"charset\" ? \"charset\" : \"content\";\n    },\n    resolveKeyData({ key }) {\n      return resolveMetaKeyValue(key);\n    },\n    resolveValueData({ value, key }) {\n      if (value === null)\n        return \"_null\";\n      if (typeof value === \"object\")\n        return resolvePackedMetaObjectValue(value, key);\n      return typeof value === \"number\" ? value.toString() : value;\n    }\n  });\n  return [...extras, ...meta].map((m) => {\n    if (m.content === \"_null\")\n      m.content = null;\n    return m;\n  });\n}\nfunction packMeta(inputs) {\n  const mappedPackingSchema = Object.entries(MetaPackingSchema).map(([key, value]) => [key, value.keyValue]);\n  return packArray(inputs, {\n    key: [\"name\", \"property\", \"httpEquiv\", \"http-equiv\", \"charset\"],\n    value: [\"content\", \"charset\"],\n    resolveKey(k2) {\n      let key = mappedPackingSchema.filter((sk) => sk[1] === k2)?.[0]?.[0] || k2;\n      const replacer = (_, letter) => letter?.toUpperCase();\n      key = key.replace(/:([a-z])/g, replacer).replace(/-([a-z])/g, replacer);\n      return key;\n    }\n  });\n}\n\nconst WhitelistAttributes = {\n  htmlAttrs: [\"id\", \"class\", \"lang\", \"dir\"],\n  bodyAttrs: [\"id\", \"class\"],\n  meta: [\"id\", \"name\", \"property\", \"charset\", \"content\"],\n  noscript: [\"id\", \"textContent\"],\n  script: [\"id\", \"type\", \"textContent\"],\n  link: [\"id\", \"color\", \"crossorigin\", \"fetchpriority\", \"href\", \"hreflang\", \"imagesrcset\", \"imagesizes\", \"integrity\", \"media\", \"referrerpolicy\", \"rel\", \"sizes\", \"type\"]\n};\nfunction acceptDataAttrs(value) {\n  const filtered = {};\n  Object.keys(value || {}).filter((a) => a.startsWith(\"data-\")).forEach((a) => {\n    filtered[a] = value[a];\n  });\n  return filtered;\n}\nfunction whitelistSafeInput(input) {\n  const filtered = {};\n  Object.keys(input).forEach((key) => {\n    const tagValue = input[key];\n    if (!tagValue)\n      return;\n    switch (key) {\n      case \"title\":\n      case \"titleTemplate\":\n      case \"templateParams\":\n        filtered[key] = tagValue;\n        break;\n      case \"htmlAttrs\":\n      case \"bodyAttrs\":\n        filtered[key] = acceptDataAttrs(tagValue);\n        WhitelistAttributes[key].forEach((a) => {\n          if (tagValue[a])\n            filtered[key][a] = tagValue[a];\n        });\n        break;\n      case \"meta\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((meta) => {\n            const safeMeta = acceptDataAttrs(meta);\n            WhitelistAttributes.meta.forEach((key2) => {\n              if (meta[key2])\n                safeMeta[key2] = meta[key2];\n            });\n            return safeMeta;\n          }).filter((meta) => Object.keys(meta).length > 0);\n        }\n        break;\n      case \"link\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((meta) => {\n            const link = acceptDataAttrs(meta);\n            WhitelistAttributes.link.forEach((key2) => {\n              const val = meta[key2];\n              if (key2 === \"rel\" && [\"stylesheet\", \"canonical\", \"modulepreload\", \"prerender\", \"preload\", \"prefetch\"].includes(val))\n                return;\n              if (key2 === \"href\") {\n                if (val.includes(\"javascript:\") || val.includes(\"data:\"))\n                  return;\n                link[key2] = val;\n              } else if (val) {\n                link[key2] = val;\n              }\n            });\n            return link;\n          }).filter((link) => Object.keys(link).length > 1 && !!link.rel);\n        }\n        break;\n      case \"noscript\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((meta) => {\n            const noscript = acceptDataAttrs(meta);\n            WhitelistAttributes.noscript.forEach((key2) => {\n              if (meta[key2])\n                noscript[key2] = meta[key2];\n            });\n            return noscript;\n          }).filter((meta) => Object.keys(meta).length > 0);\n        }\n        break;\n      case \"script\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((script) => {\n            const safeScript = acceptDataAttrs(script);\n            WhitelistAttributes.script.forEach((s) => {\n              if (script[s]) {\n                if (s === \"textContent\") {\n                  try {\n                    const jsonVal = typeof script[s] === \"string\" ? JSON.parse(script[s]) : script[s];\n                    safeScript[s] = JSON.stringify(jsonVal, null, 0);\n                  } catch (e) {\n                  }\n                } else {\n                  safeScript[s] = script[s];\n                }\n              }\n            });\n            return safeScript;\n          }).filter((meta) => Object.keys(meta).length > 0);\n        }\n        break;\n    }\n  });\n  return filtered;\n}\n\nasync function normaliseTag(tagName, input, e) {\n  const tag = {\n    tag: tagName,\n    props: await normaliseProps(\n      // explicitly check for an object\n      // @ts-expect-error untyped\n      typeof input === \"object\" && typeof input !== \"function\" && !(input instanceof Promise) ? { ...input } : { [[\"script\", \"noscript\", \"style\"].includes(tagName) ? \"innerHTML\" : \"textContent\"]: input },\n      [\"templateParams\", \"titleTemplate\"].includes(tagName)\n    )\n  };\n  TagConfigKeys.forEach((k) => {\n    const val = typeof tag.props[k] !== \"undefined\" ? tag.props[k] : e[k];\n    if (typeof val !== \"undefined\") {\n      if (![\"innerHTML\", \"textContent\", \"children\"].includes(k) || TagsWithInnerContent.includes(tag.tag)) {\n        tag[k === \"children\" ? \"innerHTML\" : k] = val;\n      }\n      delete tag.props[k];\n    }\n  });\n  if (tag.props.body) {\n    tag.tagPosition = \"bodyClose\";\n    delete tag.props.body;\n  }\n  if (tag.tag === \"script\") {\n    if (typeof tag.innerHTML === \"object\") {\n      tag.innerHTML = JSON.stringify(tag.innerHTML);\n      tag.props.type = tag.props.type || \"application/json\";\n    }\n  }\n  return Array.isArray(tag.props.content) ? tag.props.content.map((v) => ({ ...tag, props: { ...tag.props, content: v } })) : tag;\n}\nfunction normaliseStyleClassProps(key, v) {\n  const sep = key === \"class\" ? \" \" : \";\";\n  if (typeof v === \"object\" && !Array.isArray(v)) {\n    v = Object.entries(v).filter(([, v2]) => v2).map(([k, v2]) => key === \"style\" ? `${k}:${v2}` : k);\n  }\n  return (Array.isArray(v) ? v.join(sep) : v)?.split(sep).filter((c) => c.trim()).filter(Boolean).join(sep);\n}\nasync function normaliseProps(props, virtual) {\n  for (const k of Object.keys(props)) {\n    if ([\"class\", \"style\"].includes(k)) {\n      props[k] = normaliseStyleClassProps(k, props[k]);\n      continue;\n    }\n    if (props[k] instanceof Promise)\n      props[k] = await props[k];\n    if (!virtual && !TagConfigKeys.includes(k)) {\n      const v = String(props[k]);\n      const isDataKey = k.startsWith(\"data-\");\n      if (v === \"true\" || v === \"\") {\n        props[k] = isDataKey ? \"true\" : true;\n      } else if (!props[k]) {\n        if (isDataKey && v === \"false\")\n          props[k] = \"false\";\n        else\n          delete props[k];\n      }\n    }\n  }\n  return props;\n}\nconst TagEntityBits = 10;\nasync function normaliseEntryTags(e) {\n  const tagPromises = [];\n  Object.entries(e.resolvedInput).filter(([k, v]) => typeof v !== \"undefined\" && ValidHeadTags.includes(k)).forEach(([k, value]) => {\n    const v = asArray$1(value);\n    tagPromises.push(...v.map((props) => normaliseTag(k, props, e)).flat());\n  });\n  return (await Promise.all(tagPromises)).flat().filter(Boolean).map((t, i) => {\n    t._e = e._i;\n    e.mode && (t._m = e.mode);\n    t._p = (e._i << TagEntityBits) + i;\n    return t;\n  });\n}\n\nconst TAG_WEIGHTS = {\n  // tags\n  base: -10,\n  title: 10\n};\nconst TAG_ALIASES = {\n  // relative scores to their default values\n  critical: -80,\n  high: -10,\n  low: 20\n};\nfunction tagWeight(tag) {\n  let weight = 100;\n  const priority = tag.tagPriority;\n  if (typeof priority === \"number\")\n    return priority;\n  if (tag.tag === \"meta\") {\n    if (tag.props[\"http-equiv\"] === \"content-security-policy\")\n      weight = -30;\n    if (tag.props.charset)\n      weight = -20;\n    if (tag.props.name === \"viewport\")\n      weight = -15;\n  } else if (tag.tag === \"link\" && tag.props.rel === \"preconnect\") {\n    weight = 20;\n  } else if (tag.tag in TAG_WEIGHTS) {\n    weight = TAG_WEIGHTS[tag.tag];\n  }\n  if (typeof priority === \"string\" && priority in TAG_ALIASES) {\n    return weight + TAG_ALIASES[priority];\n  }\n  return weight;\n}\nconst SortModifiers = [{ prefix: \"before:\", offset: -1 }, { prefix: \"after:\", offset: 1 }];\n\nconst NetworkEvents = [\"onload\", \"onerror\", \"onabort\", \"onprogress\", \"onloadstart\"];\nconst ScriptNetworkEvents = [\"onload\", \"onerror\"];\n\nconst sepSub = \"%separator\";\nfunction processTemplateParams(s, p, sep) {\n  if (typeof s !== \"string\" || !s.includes(\"%\"))\n    return s;\n  function sub(token) {\n    let val;\n    if ([\"s\", \"pageTitle\"].includes(token)) {\n      val = p.pageTitle;\n    } else if (token.includes(\".\")) {\n      val = token.split(\".\").reduce((acc, key) => acc ? acc[key] || void 0 : void 0, p);\n    } else {\n      val = p[token];\n    }\n    return typeof val !== \"undefined\" ? (val || \"\").replace(/\"/g, '\\\\\"') : false;\n  }\n  let decoded = s;\n  try {\n    decoded = decodeURI(s);\n  } catch {\n  }\n  const tokens = (decoded.match(/%(\\w+\\.+\\w+)|%(\\w+)/g) || []).sort().reverse();\n  tokens.forEach((token) => {\n    const re = sub(token.slice(1));\n    if (typeof re === \"string\") {\n      s = s.replace(new RegExp(`\\\\${token}(\\\\W|$)`, \"g\"), (_, args) => `${re}${args}`).trim();\n    }\n  });\n  if (s.includes(sepSub)) {\n    if (s.endsWith(sepSub))\n      s = s.slice(0, -sepSub.length).trim();\n    if (s.startsWith(sepSub))\n      s = s.slice(sepSub.length).trim();\n    s = s.replace(new RegExp(`\\\\${sepSub}\\\\s*\\\\${sepSub}`, \"g\"), sepSub);\n    s = processTemplateParams(s, { separator: sep }, sep);\n  }\n  return s;\n}\n\nexport { HasElementTags, IsBrowser, NetworkEvents, ScriptNetworkEvents, SelfClosingTags, SortModifiers, TAG_ALIASES, TAG_WEIGHTS, TagConfigKeys, TagEntityBits, TagsWithInnerContent, UniqueTags, ValidHeadTags, asArray$1 as asArray, composableNames, defineHeadPlugin, hashCode, hashTag, normaliseEntryTags, normaliseProps, normaliseStyleClassProps, normaliseTag, packMeta, processTemplateParams, resolveMetaKeyType, resolveMetaKeyValue, resolvePackedMetaObjectValue, resolveTitleTemplate, tagDedupeKey, tagWeight, unpackMeta, whitelistSafeInput };\n","import { HasElementTags, hashTag, normaliseProps, tagDedupeKey, defineHeadPlugin } from '@unhead/shared';\n\nasync function renderDOMHead(head, options = {}) {\n  const dom = options.document || head.resolvedOptions.document;\n  if (!dom || !head.dirty)\n    return;\n  const beforeRenderCtx = { shouldRender: true, tags: [] };\n  await head.hooks.callHook(\"dom:beforeRender\", beforeRenderCtx);\n  if (!beforeRenderCtx.shouldRender)\n    return;\n  const tags = (await head.resolveTags()).map((tag) => ({\n    tag,\n    id: HasElementTags.includes(tag.tag) ? hashTag(tag) : tag.tag,\n    shouldRender: true\n  }));\n  let state = head._dom;\n  if (!state) {\n    state = {\n      elMap: { htmlAttrs: dom.documentElement, bodyAttrs: dom.body }\n    };\n    for (const key of [\"body\", \"head\"]) {\n      const children = dom[key]?.children;\n      const tags2 = [];\n      for (const c of [...children].filter((c2) => HasElementTags.includes(c2.tagName.toLowerCase()))) {\n        const t = {\n          tag: c.tagName.toLowerCase(),\n          props: await normaliseProps(\n            c.getAttributeNames().reduce((props, name) => ({ ...props, [name]: c.getAttribute(name) }), {})\n          ),\n          innerHTML: c.innerHTML\n        };\n        let i = 1;\n        let d = tagDedupeKey(t);\n        while (d && tags2.find((t2) => t2._d === d))\n          d = `${d}:${i++}`;\n        t._d = d || void 0;\n        tags2.push(t);\n        state.elMap[c.getAttribute(\"data-hid\") || hashTag(t)] = c;\n      }\n    }\n  }\n  state.pendingSideEffects = { ...state.sideEffects || {} };\n  state.sideEffects = {};\n  function track(id, scope, fn) {\n    const k = `${id}:${scope}`;\n    state.sideEffects[k] = fn;\n    delete state.pendingSideEffects[k];\n  }\n  function trackCtx({ id, $el, tag }) {\n    const isAttrTag = tag.tag.endsWith(\"Attrs\");\n    state.elMap[id] = $el;\n    if (!isAttrTag) {\n      [\"textContent\", \"innerHTML\"].forEach((k) => {\n        tag[k] && tag[k] !== $el[k] && ($el[k] = tag[k]);\n      });\n      track(id, \"el\", () => {\n        state.elMap[id]?.remove();\n        delete state.elMap[id];\n      });\n    }\n    for (const [k, value] of Object.entries(tag._eventHandlers || {})) {\n      if ($el.getAttribute(`data-${k}`) !== \"\") {\n        (tag.tag === \"bodyAttrs\" ? dom.defaultView : $el).addEventListener(k.replace(\"on\", \"\"), value.bind($el));\n        $el.setAttribute(`data-${k}`, \"\");\n      }\n    }\n    Object.entries(tag.props).forEach(([k, value]) => {\n      const ck = `attr:${k}`;\n      if (k === \"class\") {\n        for (const c of (value || \"\").split(\" \").filter(Boolean)) {\n          isAttrTag && track(id, `${ck}:${c}`, () => $el.classList.remove(c));\n          !$el.classList.contains(c) && $el.classList.add(c);\n        }\n      } else if (k === \"style\") {\n        for (const c of (value || \"\").split(\";\").filter(Boolean)) {\n          const [k2, ...v] = c.split(\":\").map((s) => s.trim());\n          track(id, `${ck}:${c}:${k2}`, () => {\n            $el.style.removeProperty(k2);\n          });\n          $el.style.setProperty(k2, v.join(\":\"));\n        }\n      } else {\n        $el.getAttribute(k) !== value && $el.setAttribute(k, value === true ? \"\" : String(value));\n        isAttrTag && track(id, ck, () => $el.removeAttribute(k));\n      }\n    });\n  }\n  const pending = [];\n  const frag = {\n    bodyClose: void 0,\n    bodyOpen: void 0,\n    head: void 0\n  };\n  for (const ctx of tags) {\n    const { tag, shouldRender, id } = ctx;\n    if (!shouldRender)\n      continue;\n    if (tag.tag === \"title\") {\n      dom.title = tag.textContent;\n      continue;\n    }\n    ctx.$el = ctx.$el || state.elMap[id];\n    if (ctx.$el)\n      trackCtx(ctx);\n    else\n      HasElementTags.includes(tag.tag) && pending.push(ctx);\n  }\n  for (const ctx of pending) {\n    const pos = ctx.tag.tagPosition || \"head\";\n    ctx.$el = dom.createElement(ctx.tag.tag);\n    trackCtx(ctx);\n    frag[pos] = frag[pos] || dom.createDocumentFragment();\n    frag[pos].appendChild(ctx.$el);\n  }\n  for (const ctx of tags)\n    await head.hooks.callHook(\"dom:renderTag\", ctx, dom, track);\n  frag.head && dom.head.appendChild(frag.head);\n  frag.bodyOpen && dom.body.insertBefore(frag.bodyOpen, dom.body.firstChild);\n  frag.bodyClose && dom.body.appendChild(frag.bodyClose);\n  Object.values(state.pendingSideEffects).forEach((fn) => fn());\n  head._dom = state;\n  head.dirty = false;\n  await head.hooks.callHook(\"dom:rendered\", { renders: tags });\n}\n\nasync function debouncedRenderDOMHead(head, options = {}) {\n  const fn = options.delayFn || ((fn2) => setTimeout(fn2, 10));\n  return head._domUpdatePromise = head._domUpdatePromise || new Promise((resolve) => fn(async () => {\n    await renderDOMHead(head, options);\n    delete head._domUpdatePromise;\n    resolve();\n  }));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction DomPlugin(options) {\n  return defineHeadPlugin((head) => {\n    const initialPayload = head.resolvedOptions.document?.head.querySelector('script[id=\"unhead:payload\"]')?.innerHTML || false;\n    initialPayload && head.push(JSON.parse(initialPayload));\n    return {\n      mode: \"client\",\n      hooks: {\n        \"entries:updated\": function(head2) {\n          debouncedRenderDOMHead(head2, options);\n        }\n      }\n    };\n  });\n}\n\nexport { DomPlugin, debouncedRenderDOMHead, renderDOMHead };\n","import { createHooks } from 'hookable';\nimport { DomPlugin } from '@unhead/dom';\nimport { defineHeadPlugin, tagDedupeKey, tagWeight, HasElementTags, NetworkEvents, hashCode, SortModifiers, processTemplateParams, resolveTitleTemplate, IsBrowser, normaliseEntryTags, composableNames, whitelistSafeInput, unpackMeta, ScriptNetworkEvents } from '@unhead/shared';\nexport { composableNames } from '@unhead/shared';\n\nconst UsesMergeStrategy = [\"templateParams\", \"htmlAttrs\", \"bodyAttrs\"];\nconst DedupePlugin = defineHeadPlugin({\n  hooks: {\n    \"tag:normalise\": function({ tag }) {\n      [\"hid\", \"vmid\", \"key\"].forEach((key) => {\n        if (tag.props[key]) {\n          tag.key = tag.props[key];\n          delete tag.props[key];\n        }\n      });\n      const generatedKey = tagDedupeKey(tag);\n      const dedupe = generatedKey || (tag.key ? `${tag.tag}:${tag.key}` : false);\n      if (dedupe)\n        tag._d = dedupe;\n    },\n    \"tags:resolve\": function(ctx) {\n      const deduping = {};\n      ctx.tags.forEach((tag) => {\n        const dedupeKey = (tag.key ? `${tag.tag}:${tag.key}` : tag._d) || tag._p;\n        const dupedTag = deduping[dedupeKey];\n        if (dupedTag) {\n          let strategy = tag?.tagDuplicateStrategy;\n          if (!strategy && UsesMergeStrategy.includes(tag.tag))\n            strategy = \"merge\";\n          if (strategy === \"merge\") {\n            const oldProps = dupedTag.props;\n            [\"class\", \"style\"].forEach((key) => {\n              if (oldProps[key]) {\n                if (tag.props[key]) {\n                  if (key === \"style\" && !oldProps[key].endsWith(\";\"))\n                    oldProps[key] += \";\";\n                  tag.props[key] = `${oldProps[key]} ${tag.props[key]}`;\n                } else {\n                  tag.props[key] = oldProps[key];\n                }\n              }\n            });\n            deduping[dedupeKey].props = {\n              ...oldProps,\n              ...tag.props\n            };\n            return;\n          } else if (tag._e === dupedTag._e) {\n            dupedTag._duped = dupedTag._duped || [];\n            tag._d = `${dupedTag._d}:${dupedTag._duped.length + 1}`;\n            dupedTag._duped.push(tag);\n            return;\n          } else if (tagWeight(tag) > tagWeight(dupedTag)) {\n            return;\n          }\n        }\n        const propCount = Object.keys(tag.props).length + (tag.innerHTML ? 1 : 0) + (tag.textContent ? 1 : 0);\n        if (HasElementTags.includes(tag.tag) && propCount === 0) {\n          delete deduping[dedupeKey];\n          return;\n        }\n        deduping[dedupeKey] = tag;\n      });\n      const newTags = [];\n      Object.values(deduping).forEach((tag) => {\n        const dupes = tag._duped;\n        delete tag._duped;\n        newTags.push(tag);\n        if (dupes)\n          newTags.push(...dupes);\n      });\n      ctx.tags = newTags;\n      ctx.tags = ctx.tags.filter((t) => !(t.tag === \"meta\" && (t.props.name || t.props.property) && !t.props.content));\n    }\n  }\n});\n\nconst PayloadPlugin = defineHeadPlugin({\n  mode: \"server\",\n  hooks: {\n    \"tags:resolve\": function(ctx) {\n      const payload = {};\n      ctx.tags.filter((tag) => [\"titleTemplate\", \"templateParams\", \"title\"].includes(tag.tag) && tag._m === \"server\").forEach((tag) => {\n        payload[tag.tag] = tag.tag.startsWith(\"title\") ? tag.textContent : tag.props;\n      });\n      Object.keys(payload).length && ctx.tags.push({\n        tag: \"script\",\n        innerHTML: JSON.stringify(payload),\n        props: { id: \"unhead:payload\", type: \"application/json\" }\n      });\n    }\n  }\n});\n\nconst ValidEventTags = [\"script\", \"link\", \"bodyAttrs\"];\nconst EventHandlersPlugin = defineHeadPlugin((head) => ({\n  hooks: {\n    \"tags:resolve\": function(ctx) {\n      for (const tag of ctx.tags.filter((t) => ValidEventTags.includes(t.tag))) {\n        Object.entries(tag.props).forEach(([key, value]) => {\n          if (key.startsWith(\"on\") && typeof value === \"function\") {\n            if (head.ssr && NetworkEvents.includes(key))\n              tag.props[key] = `this.dataset.${key}fired = true`;\n            else\n              delete tag.props[key];\n            tag._eventHandlers = tag._eventHandlers || {};\n            tag._eventHandlers[key] = value;\n          }\n        });\n        if (head.ssr && tag._eventHandlers && (tag.props.src || tag.props.href))\n          tag.key = tag.key || hashCode(tag.props.src || tag.props.href);\n      }\n    },\n    \"dom:renderTag\": function({ $el, tag }) {\n      for (const k of Object.keys($el?.dataset || {}).filter((k2) => NetworkEvents.some((e) => `${e}fired` === k2))) {\n        const ek = k.replace(\"fired\", \"\");\n        tag._eventHandlers?.[ek]?.call($el, new Event(ek.replace(\"on\", \"\")));\n      }\n    }\n  }\n}));\n\nconst DupeableTags = [\"link\", \"style\", \"script\", \"noscript\"];\nconst HashKeyedPlugin = defineHeadPlugin({\n  hooks: {\n    \"tag:normalise\": ({ tag }) => {\n      if (tag.key && DupeableTags.includes(tag.tag)) {\n        tag.props[\"data-hid\"] = tag._h = hashCode(tag.key);\n      }\n    }\n  }\n});\n\nconst SortPlugin = defineHeadPlugin({\n  hooks: {\n    \"tags:resolve\": (ctx) => {\n      const tagPositionForKey = (key) => ctx.tags.find((tag) => tag._d === key)?._p;\n      for (const { prefix, offset } of SortModifiers) {\n        for (const tag of ctx.tags.filter((tag2) => typeof tag2.tagPriority === \"string\" && tag2.tagPriority.startsWith(prefix))) {\n          const position = tagPositionForKey(\n            tag.tagPriority.replace(prefix, \"\")\n          );\n          if (typeof position !== \"undefined\")\n            tag._p = position + offset;\n        }\n      }\n      ctx.tags.sort((a, b) => a._p - b._p).sort((a, b) => tagWeight(a) - tagWeight(b));\n    }\n  }\n});\n\nconst SupportedAttrs = {\n  meta: \"content\",\n  link: \"href\",\n  htmlAttrs: \"lang\"\n};\nconst TemplateParamsPlugin = defineHeadPlugin((head) => ({\n  hooks: {\n    \"tags:resolve\": (ctx) => {\n      const { tags } = ctx;\n      const title = tags.find((tag) => tag.tag === \"title\")?.textContent;\n      const idx = tags.findIndex((tag) => tag.tag === \"templateParams\");\n      const params = idx !== -1 ? tags[idx].props : {};\n      const sep = params.separator || \"|\";\n      delete params.separator;\n      params.pageTitle = processTemplateParams(params.pageTitle || title || \"\", params, sep);\n      for (const tag of tags.filter((t) => t.processTemplateParams !== false)) {\n        const v = SupportedAttrs[tag.tag];\n        if (v && typeof tag.props[v] === \"string\") {\n          tag.props[v] = processTemplateParams(tag.props[v], params, sep);\n        } else if (tag.processTemplateParams === true || [\"titleTemplate\", \"title\"].includes(tag.tag)) {\n          [\"innerHTML\", \"textContent\"].forEach((p) => {\n            if (typeof tag[p] === \"string\")\n              tag[p] = processTemplateParams(tag[p], params, sep);\n          });\n        }\n      }\n      head._templateParams = params;\n      head._separator = sep;\n      ctx.tags = tags.filter((tag) => tag.tag !== \"templateParams\");\n    }\n  }\n}));\n\nconst TitleTemplatePlugin = defineHeadPlugin({\n  hooks: {\n    \"tags:resolve\": (ctx) => {\n      const { tags } = ctx;\n      let titleTemplateIdx = tags.findIndex((i) => i.tag === \"titleTemplate\");\n      const titleIdx = tags.findIndex((i) => i.tag === \"title\");\n      if (titleIdx !== -1 && titleTemplateIdx !== -1) {\n        const newTitle = resolveTitleTemplate(\n          tags[titleTemplateIdx].textContent,\n          tags[titleIdx].textContent\n        );\n        if (newTitle !== null) {\n          tags[titleIdx].textContent = newTitle || tags[titleIdx].textContent;\n        } else {\n          delete tags[titleIdx];\n        }\n      } else if (titleTemplateIdx !== -1) {\n        const newTitle = resolveTitleTemplate(\n          tags[titleTemplateIdx].textContent\n        );\n        if (newTitle !== null) {\n          tags[titleTemplateIdx].textContent = newTitle;\n          tags[titleTemplateIdx].tag = \"title\";\n          titleTemplateIdx = -1;\n        }\n      }\n      if (titleTemplateIdx !== -1) {\n        delete tags[titleTemplateIdx];\n      }\n      ctx.tags = tags.filter(Boolean);\n    }\n  }\n});\n\nconst XSSPlugin = defineHeadPlugin({\n  hooks: {\n    \"tags:afterResolve\": function(ctx) {\n      for (const tag of ctx.tags) {\n        if (typeof tag.innerHTML === \"string\") {\n          if (tag.innerHTML && [\"application/ld+json\", \"application/json\"].includes(tag.props.type)) {\n            tag.innerHTML = tag.innerHTML.replace(/</g, \"\\\\u003C\");\n          } else {\n            tag.innerHTML = tag.innerHTML.replace(new RegExp(`</${tag.tag}`, \"g\"), `<\\\\/${tag.tag}`);\n          }\n        }\n      }\n    }\n  }\n});\n\nlet activeHead;\n// @__NO_SIDE_EFFECTS__\nfunction createHead(options = {}) {\n  const head = createHeadCore(options);\n  head.use(DomPlugin());\n  return activeHead = head;\n}\n// @__NO_SIDE_EFFECTS__\nfunction createServerHead(options = {}) {\n  return activeHead = createHeadCore(options);\n}\nfunction filterMode(mode, ssr) {\n  return !mode || mode === \"server\" && ssr || mode === \"client\" && !ssr;\n}\nfunction createHeadCore(options = {}) {\n  const hooks = createHooks();\n  hooks.addHooks(options.hooks || {});\n  options.document = options.document || (IsBrowser ? document : void 0);\n  const ssr = !options.document;\n  const updated = () => {\n    head.dirty = true;\n    hooks.callHook(\"entries:updated\", head);\n  };\n  let entryCount = 0;\n  let entries = [];\n  const plugins = [];\n  const head = {\n    plugins,\n    dirty: false,\n    resolvedOptions: options,\n    hooks,\n    headEntries() {\n      return entries;\n    },\n    use(p) {\n      const plugin = typeof p === \"function\" ? p(head) : p;\n      if (!plugin.key || !plugins.some((p2) => p2.key === plugin.key)) {\n        plugins.push(plugin);\n        filterMode(plugin.mode, ssr) && hooks.addHooks(plugin.hooks || {});\n      }\n    },\n    push(input, entryOptions) {\n      delete entryOptions?.head;\n      const entry = {\n        _i: entryCount++,\n        input,\n        ...entryOptions\n      };\n      if (filterMode(entry.mode, ssr)) {\n        entries.push(entry);\n        updated();\n      }\n      return {\n        dispose() {\n          entries = entries.filter((e) => e._i !== entry._i);\n          hooks.callHook(\"entries:updated\", head);\n          updated();\n        },\n        // a patch is the same as creating a new entry, just a nice DX\n        patch(input2) {\n          entries = entries.map((e) => {\n            if (e._i === entry._i) {\n              e.input = entry.input = input2;\n            }\n            return e;\n          });\n          updated();\n        }\n      };\n    },\n    async resolveTags() {\n      const resolveCtx = { tags: [], entries: [...entries] };\n      await hooks.callHook(\"entries:resolve\", resolveCtx);\n      for (const entry of resolveCtx.entries) {\n        const resolved = entry.resolvedInput || entry.input;\n        entry.resolvedInput = await (entry.transform ? entry.transform(resolved) : resolved);\n        if (entry.resolvedInput) {\n          for (const tag of await normaliseEntryTags(entry)) {\n            const tagCtx = { tag, entry, resolvedOptions: head.resolvedOptions };\n            await hooks.callHook(\"tag:normalise\", tagCtx);\n            resolveCtx.tags.push(tagCtx.tag);\n          }\n        }\n      }\n      await hooks.callHook(\"tags:beforeResolve\", resolveCtx);\n      await hooks.callHook(\"tags:resolve\", resolveCtx);\n      await hooks.callHook(\"tags:afterResolve\", resolveCtx);\n      return resolveCtx.tags;\n    },\n    ssr\n  };\n  [\n    DedupePlugin,\n    PayloadPlugin,\n    EventHandlersPlugin,\n    HashKeyedPlugin,\n    SortPlugin,\n    TemplateParamsPlugin,\n    TitleTemplatePlugin,\n    XSSPlugin,\n    ...options?.plugins || []\n  ].forEach((p) => head.use(p));\n  head.hooks.callHook(\"init\", head);\n  return head;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction HashHydrationPlugin() {\n  return defineHeadPlugin({});\n}\n\nconst importRe = /@import/;\n// @__NO_SIDE_EFFECTS__\nfunction CapoPlugin(options) {\n  return defineHeadPlugin({\n    hooks: {\n      \"tags:beforeResolve\": function({ tags }) {\n        for (const tag of tags) {\n          if (tag.tagPosition && tag.tagPosition !== \"head\")\n            continue;\n          tag.tagPriority = tag.tagPriority || tagWeight(tag);\n          if (tag.tagPriority !== 100)\n            continue;\n          const isTruthy = (val) => val === \"\" || val === true;\n          const isScript = tag.tag === \"script\";\n          const isLink = tag.tag === \"link\";\n          if (isScript && isTruthy(tag.props.async)) {\n            tag.tagPriority = 30;\n          } else if (tag.tag === \"style\" && tag.innerHTML && importRe.test(tag.innerHTML)) {\n            tag.tagPriority = 40;\n          } else if (isScript && tag.props.src && !isTruthy(tag.props.defer) && !isTruthy(tag.props.async) && tag.props.type !== \"module\" && !tag.props.type?.endsWith(\"json\")) {\n            tag.tagPriority = 50;\n          } else if (isLink && tag.props.rel === \"stylesheet\" || tag.tag === \"style\") {\n            tag.tagPriority = 60;\n          } else if (isLink && [\"preload\", \"modulepreload\"].includes(tag.props.rel)) {\n            tag.tagPriority = 70;\n          } else if (isScript && isTruthy(tag.props.defer) && tag.props.src && !isTruthy(tag.props.async)) {\n            tag.tagPriority = 80;\n          } else if (isLink && [\"prefetch\", \"dns-prefetch\", \"prerender\"].includes(tag.props.rel)) {\n            tag.tagPriority = 90;\n          }\n        }\n        options?.track && tags.push({\n          tag: \"htmlAttrs\",\n          props: {\n            \"data-capo\": \"\"\n          }\n        });\n      }\n    }\n  });\n}\n\nconst unheadComposablesImports = [\n  {\n    from: \"unhead\",\n    imports: composableNames\n  }\n];\n\nfunction getActiveHead() {\n  return activeHead;\n}\n\nfunction useHead(input, options = {}) {\n  const head = options.head || getActiveHead();\n  return head?.push(input, options);\n}\n\nfunction useHeadSafe(input, options = {}) {\n  return useHead(input, {\n    ...options || {},\n    transform: whitelistSafeInput\n  });\n}\n\nfunction useServerHead(input, options = {}) {\n  return useHead(input, { ...options, mode: \"server\" });\n}\n\nfunction useServerHeadSafe(input, options = {}) {\n  return useHeadSafe(input, { ...options, mode: \"server\" });\n}\n\nfunction useSeoMeta(input, options) {\n  const { title, titleTemplate, ...meta } = input;\n  return useHead({\n    title,\n    titleTemplate,\n    // we need to input the meta so the reactivity will be resolved\n    // @ts-expect-error runtime type\n    _flatMeta: meta\n  }, {\n    ...options,\n    transform(t) {\n      const meta2 = unpackMeta({ ...t._flatMeta });\n      delete t._flatMeta;\n      return {\n        // @ts-expect-error runtime type\n        ...t,\n        meta: meta2\n      };\n    }\n  });\n}\n\nfunction useServerSeoMeta(input, options) {\n  return useSeoMeta(input, {\n    ...options || {},\n    mode: \"server\"\n  });\n}\n\nfunction useScript(_input, _options) {\n  const input = typeof _input === \"string\" ? { src: _input } : _input;\n  const options = _options || {};\n  const head = options.head || getActiveHead();\n  if (!head)\n    throw new Error(\"Missing Unhead context.\");\n  const id = input.key || hashCode(input.src || (typeof input.innerHTML === \"string\" ? input.innerHTML : \"\"));\n  if (head._scripts?.[id])\n    return head._scripts[id];\n  const syncStatus = (s) => {\n    script.status = s;\n    head.hooks.callHook(`script:updated`, hookCtx);\n  };\n  const trigger = typeof options.trigger !== \"undefined\" ? options.trigger : \"client\";\n  ScriptNetworkEvents.forEach((fn) => {\n    const _fn = typeof input[fn] === \"function\" ? input[fn].bind(options.eventContext) : null;\n    input[fn] = (e) => {\n      syncStatus(fn === \"onload\" ? \"loaded\" : fn === \"onerror\" ? \"error\" : \"loading\");\n      _fn?.(e);\n    };\n  });\n  const proxy = { value: !head.ssr && options?.use?.() || {} };\n  const loadPromise = new Promise((resolve, reject) => {\n    const _ = head.hooks.hook(\"script:updated\", ({ script: script2 }) => {\n      if (script2.id === id && (script2.status === \"loaded\" || script2.status === \"error\")) {\n        if (script2.status === \"loaded\") {\n          if (typeof options.use === \"function\") {\n            const api = options.use();\n            api && resolve(api);\n          } else {\n            resolve({});\n          }\n        } else if (script2.status === \"error\") {\n          reject(new Error(`Failed to load script: ${input.src}`));\n        }\n        _();\n      }\n    });\n  }).then((api) => proxy.value = api);\n  const script = {\n    id,\n    status: \"awaitingLoad\",\n    remove() {\n      if (script.entry) {\n        script.entry.dispose();\n        syncStatus(\"removed\");\n        delete head._scripts?.[id];\n        return true;\n      }\n      return false;\n    },\n    load() {\n      if (!script.entry) {\n        syncStatus(\"loading\");\n        const defaults = {\n          defer: true,\n          fetchpriority: \"low\"\n        };\n        if (input.src && (input.src.startsWith(\"http\") || input.src.startsWith(\"//\"))) {\n          defaults.crossorigin = \"anonymous\";\n          defaults.referrerpolicy = \"no-referrer\";\n        }\n        options.beforeInit?.();\n        script.entry = head.push({\n          script: [{ ...defaults, ...input, key: `script.${id}` }]\n        }, options);\n      }\n      return loadPromise;\n    }\n  };\n  const hookCtx = { script };\n  if (trigger === \"client\" && !head.ssr || trigger === \"server\" && head.ssr)\n    script.load();\n  else if (trigger instanceof Promise)\n    trigger.then(script.load);\n  else if (typeof trigger === \"function\")\n    trigger(script.load);\n  const instance = new Proxy(proxy, {\n    get({ value: _ }, k) {\n      const $script = Object.assign(loadPromise, script);\n      const stub = options.stub?.({ script: $script, fn: k });\n      if (stub)\n        return stub;\n      if (k === \"$script\")\n        return $script;\n      const exists = k in _ && typeof _[k] !== \"undefined\";\n      head.hooks.callHook(\"script:instance-fn\", { script, fn: k, exists: k in _ });\n      return exists ? Reflect.get(_, k) : (...args) => loadPromise.then((api) => {\n        const _k = Reflect.get(api, k);\n        return typeof _k === \"function\" ? Reflect.apply(api[k], api, args) : _k;\n      });\n    }\n  });\n  head._scripts = Object.assign(\n    head._scripts || {},\n    { [id]: instance }\n  );\n  return instance;\n}\n\nexport { CapoPlugin, HashHydrationPlugin, createHead, createHeadCore, createServerHead, getActiveHead, unheadComposablesImports, useHead, useHeadSafe, useScript, useSeoMeta, useServerHead, useServerHeadSafe, useServerSeoMeta };\n","import { version, unref, nextTick, inject } from 'vue';\nimport { createServerHead as createServerHead$1, createHead as createHead$1, getActiveHead } from 'unhead';\nimport { defineHeadPlugin } from '@unhead/shared';\n\nconst Vue3 = version.startsWith(\"3\");\n\nfunction resolveUnref(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\nfunction resolveUnrefHeadInput(ref, lastKey = \"\") {\n  if (ref instanceof Promise)\n    return ref;\n  const root = resolveUnref(ref);\n  if (!ref || !root)\n    return root;\n  if (Array.isArray(root))\n    return root.map((r) => resolveUnrefHeadInput(r, lastKey));\n  if (typeof root === \"object\") {\n    return Object.fromEntries(\n      Object.entries(root).map(([k, v]) => {\n        if (k === \"titleTemplate\" || k.startsWith(\"on\"))\n          return [k, unref(v)];\n        return [k, resolveUnrefHeadInput(v, k)];\n      })\n    );\n  }\n  return root;\n}\n\nconst VueReactivityPlugin = defineHeadPlugin({\n  hooks: {\n    \"entries:resolve\": function(ctx) {\n      for (const entry of ctx.entries)\n        entry.resolvedInput = resolveUnrefHeadInput(entry.input);\n    }\n  }\n});\n\nconst headSymbol = \"usehead\";\nfunction vueInstall(head) {\n  const plugin = {\n    install(app) {\n      if (Vue3) {\n        app.config.globalProperties.$unhead = head;\n        app.config.globalProperties.$head = head;\n        app.provide(headSymbol, head);\n      }\n    }\n  };\n  return plugin.install;\n}\nfunction createServerHead(options = {}) {\n  const head = createServerHead$1(options);\n  head.use(VueReactivityPlugin);\n  head.install = vueInstall(head);\n  return head;\n}\nfunction createHead(options = {}) {\n  options.domDelayFn = options.domDelayFn || ((fn) => nextTick(() => setTimeout(() => fn(), 0)));\n  const head = createHead$1(options);\n  head.use(VueReactivityPlugin);\n  head.install = vueInstall(head);\n  return head;\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__unhead_injection_handler__\";\nfunction setHeadInjectionHandler(handler) {\n  _global[globalKey] = handler;\n}\nfunction injectHead() {\n  if (globalKey in _global) {\n    return _global[globalKey]();\n  }\n  const head = inject(headSymbol);\n  if (!head && process.env.NODE_ENV !== \"production\")\n    console.warn(\"Unhead is missing Vue context, falling back to shared context. This may have unexpected results.\");\n  return head || getActiveHead();\n}\n\nexport { Vue3 as V, createServerHead as a, createHead as c, headSymbol as h, injectHead as i, resolveUnrefHeadInput as r, setHeadInjectionHandler as s };\n","// src/normalize.ts\nfunction isObject(v) {\n  return typeof v === \"object\" && v !== null;\n}\nfunction normalizeOptions(options, factoryOptions) {\n  options = isObject(options) ? options : /* @__PURE__ */ Object.create(null);\n  return new Proxy(options, {\n    get(target, key, receiver) {\n      if (key === \"key\")\n        return Reflect.get(target, key, receiver);\n      return Reflect.get(target, key, receiver) || Reflect.get(factoryOptions, key, receiver);\n    }\n  });\n}\n\n// src/pick.ts\nfunction get(state, path) {\n  return path.reduce((obj, p) => {\n    return obj == null ? void 0 : obj[p];\n  }, state);\n}\nfunction set(state, path, val) {\n  return path.slice(0, -1).reduce((obj, p) => {\n    if (/^(__proto__)$/.test(p))\n      return {};\n    else\n      return obj[p] = obj[p] || {};\n  }, state)[path[path.length - 1]] = val, state;\n}\nfunction pick(baseState, paths) {\n  return paths.reduce((substate, path) => {\n    const pathArray = path.split(\".\");\n    return set(substate, pathArray, get(baseState, pathArray));\n  }, {});\n}\n\n// src/plugin.ts\nfunction parsePersistence(factoryOptions, store) {\n  return (o) => {\n    var _a;\n    try {\n      const {\n        storage = localStorage,\n        beforeRestore = void 0,\n        afterRestore = void 0,\n        serializer = {\n          serialize: JSON.stringify,\n          deserialize: JSON.parse\n        },\n        key = store.$id,\n        paths = null,\n        debug = false\n      } = o;\n      return {\n        storage,\n        beforeRestore,\n        afterRestore,\n        serializer,\n        key: ((_a = factoryOptions.key) != null ? _a : (k) => k)(typeof key == \"string\" ? key : key(store.$id)),\n        paths,\n        debug\n      };\n    } catch (e) {\n      if (o.debug)\n        console.error(\"[pinia-plugin-persistedstate]\", e);\n      return null;\n    }\n  };\n}\nfunction hydrateStore(store, { storage, serializer, key, debug }) {\n  try {\n    const fromStorage = storage == null ? void 0 : storage.getItem(key);\n    if (fromStorage)\n      store.$patch(serializer == null ? void 0 : serializer.deserialize(fromStorage));\n  } catch (e) {\n    if (debug)\n      console.error(\"[pinia-plugin-persistedstate]\", e);\n  }\n}\nfunction persistState(state, { storage, serializer, key, paths, debug }) {\n  try {\n    const toStore = Array.isArray(paths) ? pick(state, paths) : state;\n    storage.setItem(key, serializer.serialize(toStore));\n  } catch (e) {\n    if (debug)\n      console.error(\"[pinia-plugin-persistedstate]\", e);\n  }\n}\nfunction createPersistedState(factoryOptions = {}) {\n  return (context) => {\n    const { auto = false } = factoryOptions;\n    const {\n      options: { persist = auto },\n      store,\n      pinia\n    } = context;\n    if (!persist)\n      return;\n    if (!(store.$id in pinia.state.value)) {\n      const original_store = pinia._s.get(store.$id.replace(\"__hot:\", \"\"));\n      if (original_store)\n        Promise.resolve().then(() => original_store.$persist());\n      return;\n    }\n    const persistences = (Array.isArray(persist) ? persist.map((p) => normalizeOptions(p, factoryOptions)) : [normalizeOptions(persist, factoryOptions)]).map(parsePersistence(factoryOptions, store)).filter(Boolean);\n    store.$persist = () => {\n      persistences.forEach((persistence) => {\n        persistState(store.$state, persistence);\n      });\n    };\n    store.$hydrate = ({ runHooks = true } = {}) => {\n      persistences.forEach((persistence) => {\n        const { beforeRestore, afterRestore } = persistence;\n        if (runHooks)\n          beforeRestore == null ? void 0 : beforeRestore(context);\n        hydrateStore(store, persistence);\n        if (runHooks)\n          afterRestore == null ? void 0 : afterRestore(context);\n      });\n    };\n    persistences.forEach((persistence) => {\n      const { beforeRestore, afterRestore } = persistence;\n      beforeRestore == null ? void 0 : beforeRestore(context);\n      hydrateStore(store, persistence);\n      afterRestore == null ? void 0 : afterRestore(context);\n      store.$subscribe(\n        (_mutation, state) => {\n          persistState(state, persistence);\n        },\n        {\n          detached: true\n        }\n      );\n    });\n  };\n}\n\n// src/index.ts\nvar src_default = createPersistedState();\nexport {\n  createPersistedState,\n  src_default as default\n};\n"],"names":["isVue2","piniaSymbol","MutationType","createPinia","scope","effectScope","state","ref","_p","toBeInstalled","pinia","markRaw","app","plugin","flatHooks","configHooks","hooks","parentName","key","subHook","name","defaultTask","function_","_createTask","createTask","serialTaskCaller","args","task","promise","hookFunction","parallelTaskCaller","hook","callEachWith","callbacks","arg0","callback","Hookable","options","originalName","dep","message","_unreg","_function","arguments_","index","deprecated","_hooks","deprecatedHooks","removeFns","unreg","caller","event","result","createHooks","asArray$1","value","TagsWithInnerContent","HasElementTags","ValidHeadTags","UniqueTags","TagConfigKeys","IsBrowser","hashCode","s","h","i","hashTag","tag","tagDedupeKey","fn","props","tagName","val","resolveTitleTemplate","template","title","normaliseTag","input","normaliseProps","k","v","normaliseStyleClassProps","sep","v2","c","virtual","isDataKey","TagEntityBits","normaliseEntryTags","e","tagPromises","t","TAG_WEIGHTS","TAG_ALIASES","tagWeight","weight","priority","SortModifiers","NetworkEvents","sepSub","processTemplateParams","p","sub","token","acc","decoded","re","_","renderDOMHead","head","dom","beforeRenderCtx","tags","children","tags2","c2","d","t2","track","id","trackCtx","$el","isAttrTag","ck","k2","pending","frag","ctx","shouldRender","pos","debouncedRenderDOMHead","fn2","resolve","DomPlugin","initialPayload","head2","UsesMergeStrategy","DedupePlugin","dedupe","deduping","dedupeKey","dupedTag","strategy","oldProps","propCount","newTags","dupes","PayloadPlugin","payload","ValidEventTags","EventHandlersPlugin","ek","DupeableTags","HashKeyedPlugin","SortPlugin","tagPositionForKey","prefix","offset","tag2","position","a","b","SupportedAttrs","TemplateParamsPlugin","idx","params","TitleTemplatePlugin","titleTemplateIdx","titleIdx","newTitle","XSSPlugin","createHead","createHeadCore","filterMode","mode","ssr","updated","entryCount","entries","plugins","p2","entryOptions","entry","input2","resolveCtx","resolved","tagCtx","Vue3","version","resolveUnref","r","unref","resolveUnrefHeadInput","lastKey","root","VueReactivityPlugin","headSymbol","vueInstall","nextTick","createHead$1","isObject","normalizeOptions","factoryOptions","target","receiver","get","path","obj","set","pick","baseState","paths","substate","pathArray","parsePersistence","store","o","_a","storage","beforeRestore","afterRestore","serializer","debug","hydrateStore","fromStorage","persistState","toStore","createPersistedState","context","auto","persist","original_store","persistences","persistence","runHooks","_mutation","src_default"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}